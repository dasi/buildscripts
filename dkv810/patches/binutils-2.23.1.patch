diff -Nbaur binutils-2.23.1/bfd/Makefile.am binutils-2.23.1-v810/bfd/Makefile.am
--- binutils-2.23.1/bfd/Makefile.am	2012-11-13 14:17:38 +0000
+++ binutils-2.23.1-v810/bfd/Makefile.am	2013-03-09 17:59:20 +0000
@@ -140,6 +140,7 @@
 	cpu-tic80.lo \
 	cpu-tilegx.lo \
 	cpu-tilepro.lo \
+	cpu-v810.lo \
 	cpu-v850.lo \
 	cpu-vax.lo \
 	cpu-w65.lo \
@@ -221,6 +222,7 @@
 	cpu-tic80.c \
 	cpu-tilegx.c \
 	cpu-tilepro.c \
+	cpu-v810.c \
 	cpu-v850.c \
 	cpu-vax.c \
 	cpu-w65.c \
@@ -342,6 +344,7 @@
 	elf32-tic6x.lo \
 	elf32-tilegx.lo \
 	elf32-tilepro.lo \
+	elf32-v810.lo \
 	elf32-v850.lo \
 	elf32-vax.lo \
 	elf32-xc16x.lo \
@@ -530,6 +533,7 @@
 	elf32-tic6x.c \
 	elf32-tilegx.c \
 	elf32-tilepro.c \
+	elf32-v810.c \
 	elf32-v850.c \
 	elf32-vax.c \
 	elf32-xc16x.c \
diff -Nbaur binutils-2.23.1/bfd/Makefile.in binutils-2.23.1-v810/bfd/Makefile.in
--- binutils-2.23.1/bfd/Makefile.in	2012-11-13 14:17:43 +0000
+++ binutils-2.23.1-v810/bfd/Makefile.in	2013-03-09 17:59:20 +0000
@@ -439,6 +439,7 @@
 	cpu-tic80.lo \
 	cpu-tilegx.lo \
 	cpu-tilepro.lo \
+	cpu-v810.lo \
 	cpu-v850.lo \
 	cpu-vax.lo \
 	cpu-w65.lo \
@@ -520,6 +521,7 @@
 	cpu-tic80.c \
 	cpu-tilegx.c \
 	cpu-tilepro.c \
+	cpu-v810.c \
 	cpu-v850.c \
 	cpu-vax.c \
 	cpu-w65.c \
@@ -642,6 +644,7 @@
 	elf32-tic6x.lo \
 	elf32-tilegx.lo \
 	elf32-tilepro.lo \
+	elf32-v810.lo \
 	elf32-v850.lo \
 	elf32-vax.lo \
 	elf32-xc16x.lo \
@@ -830,6 +833,7 @@
 	elf32-tic6x.c \
 	elf32-tilegx.c \
 	elf32-tilepro.c \
+	elf32-v810.c \
 	elf32-v850.c \
 	elf32-vax.c \
 	elf32-xc16x.c \
@@ -1343,6 +1347,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-tic80.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-tilegx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-tilepro.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-v810.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-v850.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-vax.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-w65.Plo@am__quote@
@@ -1425,6 +1430,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-tic6x.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-tilegx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-tilepro.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-v810.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-v850.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-vax.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-xc16x.Plo@am__quote@
diff -Nbaur binutils-2.23.1/bfd/archures.c binutils-2.23.1-v810/bfd/archures.c
--- binutils-2.23.1/bfd/archures.c	2012-09-04 13:53:41 +0100
+++ binutils-2.23.1-v810/bfd/archures.c	2013-03-09 17:59:20 +0000
@@ -322,6 +322,9 @@
 .  bfd_arch_tic54x,    {* Texas Instruments TMS320C54X *}
 .  bfd_arch_tic6x,     {* Texas Instruments TMS320C6X *}
 .  bfd_arch_tic80,     {* TI TMS320c80 (MVP) *}
+.  bfd_arch_v810,      {* NEC V810 *}
+.#define bfd_mach_v810          0
+.#define bfd_mach_v830          3
 .  bfd_arch_v850,      {* NEC V850 *}
 .#define bfd_mach_v850          1
 .#define bfd_mach_v850e 	'E'
@@ -577,6 +580,7 @@
 extern const bfd_arch_info_type bfd_tic80_arch;
 extern const bfd_arch_info_type bfd_tilegx_arch;
 extern const bfd_arch_info_type bfd_tilepro_arch;
+extern const bfd_arch_info_type bfd_v810_arch;
 extern const bfd_arch_info_type bfd_v850_arch;
 extern const bfd_arch_info_type bfd_vax_arch;
 extern const bfd_arch_info_type bfd_w65_arch;
@@ -660,6 +664,7 @@
     &bfd_tic80_arch,
     &bfd_tilegx_arch,
     &bfd_tilepro_arch,
+    &bfd_v810_arch,
     &bfd_v850_arch,
     &bfd_vax_arch,
     &bfd_w65_arch,
diff -Nbaur binutils-2.23.1/bfd/bfd-in2.h binutils-2.23.1-v810/bfd/bfd-in2.h
--- binutils-2.23.1/bfd/bfd-in2.h	2012-09-04 13:53:41 +0100
+++ binutils-2.23.1-v810/bfd/bfd-in2.h	2013-03-10 21:36:47 +0000
@@ -2051,6 +2051,9 @@
   bfd_arch_tic54x,    /* Texas Instruments TMS320C54X */
   bfd_arch_tic6x,     /* Texas Instruments TMS320C6X */
   bfd_arch_tic80,     /* TI TMS320c80 (MVP) */
+  bfd_arch_v810,      /* NEC V810 */
+#define bfd_mach_v810          0
+#define bfd_mach_v830          3
   bfd_arch_v850,      /* NEC V850 */
 #define bfd_mach_v850          1
 #define bfd_mach_v850e         'E'
@@ -3737,6 +3740,27 @@
   BFD_RELOC_M32R_GOTPC_LO,
 
 /* This is a 9-bit reloc  */
+  BFD_RELOC_V810_9_PCREL,
+
+/* This is a 26-bit reloc  */
+  BFD_RELOC_V810_26_PCREL,
+
+/* This is a 16 bit offset from the short data area pointer.  */
+  BFD_RELOC_V810_SDA_16_16_OFFSET,
+
+/* This is a 16 bit offset from the zero data area pointer.  */
+  BFD_RELOC_V810_ZDA_16_16_OFFSET,
+
+/* Used for relaxing indirect function calls.  */
+  BFD_RELOC_V810_LONGCALL,
+
+/* Used for relaxing indirect jumps.  */
+  BFD_RELOC_V810_LONGJUMP,
+
+/* Used to maintain alignment whilst relaxing.  */
+  BFD_RELOC_V810_ALIGN,
+
+/* This is a 9-bit reloc  */
   BFD_RELOC_V850_9_PCREL,
 
 /* This is a 22-bit reloc  */
diff -Nbaur binutils-2.23.1/bfd/config.bfd binutils-2.23.1-v810/bfd/config.bfd
--- binutils-2.23.1/bfd/config.bfd	2012-09-04 15:14:59 +0100
+++ binutils-2.23.1-v810/bfd/config.bfd	2013-03-09 17:59:20 +0000
@@ -103,6 +103,7 @@
 spu*)            targ_archs=bfd_spu_arch ;;
 tilegx*)	 targ_archs=bfd_tilegx_arch ;;
 tilepro*)	 targ_archs=bfd_tilepro_arch ;;
+v810*)		 targ_archs=bfd_v810_arch ;;
 v850*)		 targ_archs=bfd_v850_arch ;;
 x86_64*)	 targ_archs=bfd_i386_arch ;;
 xtensa*)	 targ_archs=bfd_xtensa_arch ;;
@@ -1560,6 +1561,14 @@
     targ_defvec=bfd_elf32_tilepro_vec
     ;;
 
+  v810-*-*)
+    targ_defvec=bfd_elf32_v810_vec
+    ;;
+
+  v830-*-*)
+    targ_defvec=bfd_elf32_v830_vec
+    ;;
+
   v850*-*-*)
     targ_defvec=bfd_elf32_v850_vec
     ;;
diff -Nbaur binutils-2.23.1/bfd/configure binutils-2.23.1-v810/bfd/configure
--- binutils-2.23.1/bfd/configure	2012-11-13 14:17:40 +0000
+++ binutils-2.23.1-v810/bfd/configure	2013-03-09 17:59:20 +0000
@@ -15331,6 +15331,7 @@
     bfd_elf32_tradlittlemips_vec | bfd_elf32_tradlittlemips_freebsd_vec)
 				tb="$tb elf32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_us_cris_vec)	tb="$tb elf32-cris.lo elf32.lo $elf" ;;
+    bfd_elf32_v810_vec)		tb="$tb elf32-v810.lo elf32.lo $elf" ;;
     bfd_elf32_v850_vec)		tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     bfd_elf32_vax_vec)		tb="$tb elf32-vax.lo elf32.lo $elf" ;;
     bfd_elf32_xstormy16_vec)	tb="$tb elf32-xstormy16.lo elf32.lo $elf" ;;
diff -Nbaur binutils-2.23.1/bfd/configure.in binutils-2.23.1-v810/bfd/configure.in
--- binutils-2.23.1/bfd/configure.in	2012-11-13 14:17:38 +0000
+++ binutils-2.23.1-v810/bfd/configure.in	2013-03-09 17:59:20 +0000
@@ -823,6 +823,7 @@
     bfd_elf32_tradlittlemips_vec | bfd_elf32_tradlittlemips_freebsd_vec)
 				tb="$tb elf32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_us_cris_vec)	tb="$tb elf32-cris.lo elf32.lo $elf" ;;
+    bfd_elf32_v810_vec)		tb="$tb elf32-v810.lo elf32.lo $elf" ;;
     bfd_elf32_v850_vec)		tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     bfd_elf32_vax_vec)		tb="$tb elf32-vax.lo elf32.lo $elf" ;;
     bfd_elf32_xstormy16_vec)	tb="$tb elf32-xstormy16.lo elf32.lo $elf" ;;
diff -Nbaur binutils-2.23.1/bfd/cpu-v810.c binutils-2.23.1-v810/bfd/cpu-v810.c
--- binutils-2.23.1/bfd/cpu-v810.c	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/bfd/cpu-v810.c	2013-03-10 21:40:12 +0000
@@ -0,0 +1,42 @@
+/* BFD support for the NEC V850 processor
+   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2005, 2007,
+   2010  Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "safe-ctype.h"
+
+#define N(number, print, default, next)  \
+{  32, 32, 8, bfd_arch_v810, number, "v810", print, 2, default, \
+   bfd_default_compatible, bfd_default_scan, bfd_arch_default_fill, next }
+
+#define NEXT NULL
+
+static const bfd_arch_info_type arch_info_struct[] =
+{
+  N (bfd_mach_v830,  "v830",  FALSE, NULL)
+};
+
+#undef  NEXT
+#define NEXT & arch_info_struct[0]
+
+const bfd_arch_info_type bfd_v810_arch =
+  N (bfd_mach_v810, "v810", TRUE, NEXT);
diff -Nbaur binutils-2.23.1/bfd/elf32-v810.c binutils-2.23.1-v810/bfd/elf32-v810.c
--- binutils-2.23.1/bfd/elf32-v810.c	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/bfd/elf32-v810.c	2013-03-10 21:52:00 +0000
@@ -0,0 +1,2529 @@
+/* V810-specific support for 32-bit ELF
+   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
+   2006, 2007, 2008, 2009, 2010, 2011, 2012
+   Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+
+/* XXX FIXME: This code is littered with 32bit int, 16bit short, 8bit char
+   dependencies.  As is the gas & simulator code for the v810.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/v810.h"
+#include "libiberty.h"
+
+static reloc_howto_type v810_elf_howto_table[];
+
+/* Look through the relocs for a section during the first phase, and
+   allocate space in the global offset table or procedure linkage
+   table.  */
+
+static bfd_boolean
+v810_elf_check_relocs (bfd *abfd,
+		       struct bfd_link_info *info,
+		       asection *sec,
+		       const Elf_Internal_Rela *relocs)
+{
+  bfd_boolean ret = TRUE;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel;
+  const Elf_Internal_Rela *rel_end;
+  enum v810_reloc_type r_type;
+  int other = 0;
+  const char *common = NULL;
+
+  if (info->relocatable)
+    return TRUE;
+
+#ifdef DEBUG
+  _bfd_error_handler ("v810_elf_check_relocs called for section %A in %B",
+		      sec, abfd);
+#endif
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      unsigned long r_symndx;
+      struct elf_link_hash_entry *h;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (r_symndx < symtab_hdr->sh_info)
+	h = NULL;
+      else
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	}
+
+      r_type = (enum v810_reloc_type) ELF32_R_TYPE (rel->r_info);
+      switch (r_type)
+	{
+	default:
+	case R_V810_NONE:
+	case R_V810_9_PCREL:
+	case R_V810_26_PCREL:
+	case R_V810_HI16:
+	case R_V810_HI16_S:
+	case R_V810_LO16:
+	case R_V810_32:
+	case R_V810_16:
+	case R_V810_8:
+	  break;
+
+        /* This relocation describes the C++ object vtable hierarchy.
+           Reconstruct it for later use during GC.  */
+        case R_V810_GNU_VTINHERIT:
+          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+            return FALSE;
+          break;
+
+        /* This relocation describes which C++ vtable entries
+	   are actually used.  Record for later use during GC.  */
+        case R_V810_GNU_VTENTRY:
+          BFD_ASSERT (h != NULL);
+          if (h != NULL
+              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
+            return FALSE;
+          break;
+
+	case R_V810_SDA_16_16_OFFSET:
+	  other = V810_OTHER_SDA;
+	  common = ".scommon";
+	  goto small_data_common;
+
+	case R_V810_ZDA_16_16_OFFSET:
+	  other = V810_OTHER_ZDA;
+	  common = ".zcommon";
+	  goto small_data_common;
+	  /* fall through */
+
+#define V810_OTHER_MASK (V810_OTHER_SDA | V810_OTHER_ZDA)
+
+	small_data_common:
+	  if (h)
+	    {
+	      /* Flag which type of relocation was used.  */
+	      h->other |= other;
+	      if ((h->other & V810_OTHER_MASK) != (other & V810_OTHER_MASK)
+		  && (h->other & V810_OTHER_ERROR) == 0)
+		{
+		  const char * msg;
+		  static char  buff[200]; /* XXX */
+
+		  switch (h->other & V810_OTHER_MASK)
+		    {
+		    default:
+		      msg = _("Variable `%s' cannot occupy in multiple small data regions");
+		      break;
+		    case V810_OTHER_SDA | V810_OTHER_ZDA:
+		      msg = _("Variable `%s' cannot be in both small and zero data regions simultaneously");
+		      break;
+		    }
+
+		  sprintf (buff, msg, h->root.root.string);
+		  info->callbacks->warning (info, buff, h->root.root.string,
+					    abfd, h->root.u.def.section,
+					    (bfd_vma) 0);
+
+		  bfd_set_error (bfd_error_bad_value);
+		  h->other |= V810_OTHER_ERROR;
+		  ret = FALSE;
+		}
+	    }
+
+	  if (h && h->root.type == bfd_link_hash_common
+	      && h->root.u.c.p
+	      && !strcmp (bfd_get_section_name (abfd, h->root.u.c.p->section), "COMMON"))
+	    {
+	      asection * section;
+
+	      section = h->root.u.c.p->section = bfd_make_section_old_way (abfd, common);
+	      section->flags |= SEC_IS_COMMON;
+	    }
+
+#ifdef DEBUG
+	  fprintf (stderr, "v810_elf_check_relocs, found %s relocation for %s%s\n",
+		   v810_elf_howto_table[ (int)r_type ].name,
+		   (h && h->root.root.string) ? h->root.root.string : "<unknown>",
+		   (h->root.type == bfd_link_hash_common) ? ", symbol is common" : "");
+#endif
+	  break;
+	}
+    }
+
+  return ret;
+}
+
+/* In the old version, when an entry was checked out from the table,
+   it was deleted.  This produced an error if the entry was needed
+   more than once, as the second attempted retry failed.
+
+   In the current version, the entry is not deleted, instead we set
+   the field 'found' to TRUE.  If a second lookup matches the same
+   entry, then we know that the hi16s reloc has already been updated
+   and does not need to be updated a second time.
+
+   TODO - TOFIX: If it is possible that we need to restore 2 different
+   addresses from the same table entry, where the first generates an
+   overflow, whilst the second do not, then this code will fail.  */
+
+typedef struct hi16s_location
+{
+  bfd_vma                 addend;
+  bfd_byte *              address;
+  unsigned long           counter;
+  bfd_boolean             found;
+  struct hi16s_location * next;
+}
+hi16s_location;
+
+static hi16s_location * previous_hi16s;
+static hi16s_location * free_hi16s;
+static unsigned long    hi16s_counter;
+
+static void
+remember_hi16s_reloc (bfd *abfd, bfd_vma addend, bfd_byte *address)
+{
+  hi16s_location * entry = NULL;
+  bfd_size_type amt = sizeof (* free_hi16s);
+
+  /* Find a free structure.  */
+  if (free_hi16s == NULL)
+    free_hi16s = bfd_zalloc (abfd, amt);
+
+  entry      = free_hi16s;
+  free_hi16s = free_hi16s->next;
+
+  entry->addend  = addend;
+  entry->address = address;
+  entry->counter = hi16s_counter ++;
+  entry->found   = FALSE;
+  entry->next    = previous_hi16s;
+  previous_hi16s = entry;
+
+  /* Cope with wrap around of our counter.  */
+  if (hi16s_counter == 0)
+    {
+      /* XXX: Assume that all counter entries differ only in their low 16 bits.  */
+      for (entry = previous_hi16s; entry != NULL; entry = entry->next)
+	entry->counter &= 0xffff;
+
+      hi16s_counter = 0x10000;
+    }
+}
+
+static bfd_byte *
+find_remembered_hi16s_reloc (bfd_vma addend, bfd_boolean *already_found)
+{
+  hi16s_location *match = NULL;
+  hi16s_location *entry;
+  bfd_byte *addr;
+
+  /* Search the table.  Record the most recent entry that matches.  */
+  for (entry = previous_hi16s; entry; entry = entry->next)
+    {
+      if (entry->addend == addend
+	  && (match == NULL || match->counter < entry->counter))
+	{
+	  match    = entry;
+	}
+    }
+
+  if (match == NULL)
+    return NULL;
+
+  /* Extract the address.  */
+  addr = match->address;
+
+  /* Remember if this entry has already been used before.  */
+  if (already_found)
+    * already_found = match->found;
+
+  /* Note that this entry has now been used.  */
+  match->found = TRUE;
+
+  return addr;
+}
+
+/* Calculate the final operand value for a R_V810_LO16 or
+   R_V810_LO16_SPLIT_OFFSET.  *INSN is the current operand value and
+   ADDEND is the sum of the relocation symbol and offset.  Store the
+   operand value in *INSN and return true on success.
+
+   The assembler has already done some of this: If the value stored in
+   the instruction has its 15th bit set, (counting from zero) then the
+   assembler will have added 1 to the value stored in the associated
+   HI16S reloc.  So for example, these relocations:
+
+       movhi hi( fred ), r0, r1
+       movea lo( fred ), r1, r1
+
+   will store 0 in the value fields for the MOVHI and MOVEA instructions
+   and addend will be the address of fred, but for these instructions:
+
+       movhi hi( fred + 0x123456 ), r0, r1
+       movea lo( fred + 0x123456 ), r1, r1
+
+   the value stored in the MOVHI instruction will be 0x12 and the value
+   stored in the MOVEA instruction will be 0x3456.  If however the
+   instructions were:
+
+       movhi hi( fred + 0x10ffff ), r0, r1
+       movea lo( fred + 0x10ffff ), r1, r1
+
+   then the value stored in the MOVHI instruction would be 0x11 (not
+   0x10) and the value stored in the MOVEA instruction would be 0xffff.
+   Thus (assuming for the moment that the addend is 0), at run time the
+   MOVHI instruction loads 0x110000 into r1, then the MOVEA instruction
+   adds 0xffffffff (sign extension!) producing 0x10ffff.  Similarly if
+   the instructions were:
+
+       movhi hi( fred - 1 ), r0, r1
+       movea lo( fred - 1 ), r1, r1
+
+   then 0 is stored in the MOVHI instruction and -1 is stored in the
+   MOVEA instruction.
+
+   Overflow can occur if the addition of the value stored in the
+   instruction plus the addend sets the 15th bit when before it was clear.
+   This is because the 15th bit will be sign extended into the high part,
+   thus reducing its value by one, but since the 15th bit was originally
+   clear, the assembler will not have added 1 to the previous HI16S reloc
+   to compensate for this effect.  For example:
+
+      movhi hi( fred + 0x123456 ), r0, r1
+      movea lo( fred + 0x123456 ), r1, r1
+
+   The value stored in HI16S reloc is 0x12, the value stored in the LO16
+   reloc is 0x3456.  If we assume that the address of fred is 0x00007000
+   then the relocations become:
+
+     HI16S: 0x0012 + (0x00007000 >> 16)    = 0x12
+     LO16:  0x3456 + (0x00007000 & 0xffff) = 0xa456
+
+   but when the instructions are executed, the MOVEA instruction's value
+   is signed extended, so the sum becomes:
+
+	0x00120000
+      + 0xffffa456
+      ------------
+	0x0011a456    but 'fred + 0x123456' = 0x0012a456
+
+   Note that if the 15th bit was set in the value stored in the LO16
+   reloc, then we do not have to do anything:
+
+      movhi hi( fred + 0x10ffff ), r0, r1
+      movea lo( fred + 0x10ffff ), r1, r1
+
+      HI16S:  0x0011 + (0x00007000 >> 16)    = 0x11
+      LO16:   0xffff + (0x00007000 & 0xffff) = 0x6fff
+
+	0x00110000
+      + 0x00006fff
+      ------------
+	0x00116fff  = fred + 0x10ffff = 0x7000 + 0x10ffff
+
+   Overflow can also occur if the computation carries into the 16th bit
+   and it also results in the 15th bit having the same value as the 15th
+   bit of the original value.   What happens is that the HI16S reloc
+   will have already examined the 15th bit of the original value and
+   added 1 to the high part if the bit is set.  This compensates for the
+   sign extension of 15th bit of the result of the computation.  But now
+   there is a carry into the 16th bit, and this has not been allowed for.
+
+   So, for example if fred is at address 0xf000:
+
+     movhi hi( fred + 0xffff ), r0, r1    [bit 15 of the offset is set]
+     movea lo( fred + 0xffff ), r1, r1
+
+     HI16S: 0x0001 + (0x0000f000 >> 16)    = 0x0001
+     LO16:  0xffff + (0x0000f000 & 0xffff) = 0xefff   (carry into bit 16 is lost)
+
+       0x00010000
+     + 0xffffefff
+     ------------
+       0x0000efff   but 'fred + 0xffff' = 0x0001efff
+
+   Similarly, if the 15th bit remains clear, but overflow occurs into
+   the 16th bit then (assuming the address of fred is 0xf000):
+
+     movhi hi( fred + 0x7000 ), r0, r1    [bit 15 of the offset is clear]
+     movea lo( fred + 0x7000 ), r1, r1
+
+     HI16S: 0x0000 + (0x0000f000 >> 16)    = 0x0000
+     LO16:  0x7000 + (0x0000f000 & 0xffff) = 0x6fff  (carry into bit 16 is lost)
+
+       0x00000000
+     + 0x00006fff
+     ------------
+       0x00006fff   but 'fred + 0x7000' = 0x00016fff
+
+   Note - there is no need to change anything if a carry occurs, and the
+   15th bit changes its value from being set to being clear, as the HI16S
+   reloc will have already added in 1 to the high part for us:
+
+     movhi hi( fred + 0xffff ), r0, r1     [bit 15 of the offset is set]
+     movea lo( fred + 0xffff ), r1, r1
+
+     HI16S: 0x0001 + (0x00007000 >> 16)
+     LO16:  0xffff + (0x00007000 & 0xffff) = 0x6fff  (carry into bit 16 is lost)
+
+       0x00010000
+     + 0x00006fff   (bit 15 not set, so the top half is zero)
+     ------------
+       0x00016fff   which is right (assuming that fred is at 0x7000)
+
+   but if the 15th bit goes from being clear to being set, then we must
+   once again handle overflow:
+
+     movhi hi( fred + 0x7000 ), r0, r1     [bit 15 of the offset is clear]
+     movea lo( fred + 0x7000 ), r1, r1
+
+     HI16S: 0x0000 + (0x0000ffff >> 16)
+     LO16:  0x7000 + (0x0000ffff & 0xffff) = 0x6fff  (carry into bit 16)
+
+       0x00000000
+     + 0x00006fff   (bit 15 not set, so the top half is zero)
+     ------------
+       0x00006fff   which is wrong (assuming that fred is at 0xffff).  */
+
+static bfd_boolean
+v810_elf_perform_lo16_relocation (bfd *abfd, unsigned long *insn,
+				  unsigned long addend)
+{
+#define BIT15_SET(x) ((x) & 0x8000)
+#define OVERFLOWS(a,i) ((((a) & 0xffff) + (i)) > 0xffff)
+
+  if ((BIT15_SET (*insn + addend) && ! BIT15_SET (addend))
+      || (OVERFLOWS (addend, *insn)
+	  && ((! BIT15_SET (*insn)) || (BIT15_SET (addend)))))
+    {
+      bfd_boolean already_updated;
+      bfd_byte *hi16s_address = find_remembered_hi16s_reloc
+	(addend, & already_updated);
+
+      /* Amend the matching HI16_S relocation.  */
+      if (hi16s_address != NULL)
+	{
+	  if (! already_updated)
+	    {
+	      unsigned long hi_insn = bfd_get_16 (abfd, hi16s_address);
+	      hi_insn += 1;
+	      bfd_put_16 (abfd, hi_insn, hi16s_address);
+	    }
+	}
+      else
+	{
+	  (*_bfd_error_handler) (_("FAILED to find previous HI16 reloc"));
+	  return FALSE;
+	}
+    }
+#undef OVERFLOWS
+#undef BIT15_SET
+
+  /* Do not complain if value has top bit set, as this has been
+     anticipated.  */
+  *insn = (*insn + addend) & 0xffff;
+  return TRUE;
+}
+
+/* FIXME:  The code here probably ought to be removed and the code in reloc.c
+   allowed to do its stuff instead.  At least for most of the relocs, anyway.  */
+
+static bfd_reloc_status_type
+v810_elf_perform_relocation (bfd *abfd,
+			     unsigned int r_type,
+			     bfd_vma addend,
+			     bfd_byte *address)
+{
+  unsigned long insn;
+  bfd_signed_vma saddend = (bfd_signed_vma) addend;
+
+  switch (r_type)
+    {
+    default:
+      return bfd_reloc_notsupported;
+
+    case R_V810_32:
+      bfd_put_32 (abfd, addend, address);
+      return bfd_reloc_ok;
+
+    case R_V810_26_PCREL:
+      if (saddend > 0x1ffffff || saddend < -0x2000000)
+	return bfd_reloc_overflow;
+
+      if ((addend % 2) != 0)
+	return bfd_reloc_dangerous;
+
+      insn  = bfd_get_32 (abfd, address);
+      insn &= ~0xfffe03ff;
+      insn |= (((addend & 0xfffe) << 16) | ((addend & 0x3ff0000) >> 16));
+      bfd_put_32 (abfd, (bfd_vma) insn, address);
+      return bfd_reloc_ok;
+
+    case R_V810_9_PCREL:
+      if (saddend > 0xff || saddend < -0x100)
+	return bfd_reloc_overflow;
+
+      if ((addend % 2) != 0)
+	return bfd_reloc_dangerous;
+
+      insn  = bfd_get_16 (abfd, address);
+      insn &= ~ 0x01ff;
+      insn |= (addend & 0x1ff);
+      break;
+
+    case R_V810_HI16:
+      addend += (bfd_get_16 (abfd, address) << 16);
+      addend = (addend >> 16);
+      insn = addend;
+      break;
+
+    case R_V810_HI16_S:
+      /* Remember where this relocation took place.  */
+      remember_hi16s_reloc (abfd, addend, address);
+
+      addend += (bfd_get_16 (abfd, address) << 16);
+      addend = (addend >> 16) + ((addend & 0x8000) != 0);
+
+      /* This relocation cannot overflow.  */
+      if (addend > 0xffff)
+	addend = 0;
+
+      insn = addend;
+      break;
+
+    case R_V810_LO16:
+      insn = bfd_get_16 (abfd, address);
+      if (! v810_elf_perform_lo16_relocation (abfd, &insn, addend))
+	return bfd_reloc_overflow;
+      break;
+
+    case R_V810_8:
+      addend += (char) bfd_get_8 (abfd, address);
+
+      saddend = (bfd_signed_vma) addend;
+
+      if (saddend > 0x7f || saddend < -0x80)
+	return bfd_reloc_overflow;
+
+      bfd_put_8 (abfd, addend, address);
+      return bfd_reloc_ok;
+
+    case R_V810_16:
+    case R_V810_SDA_16_16_OFFSET:
+    case R_V810_ZDA_16_16_OFFSET:
+      addend += bfd_get_16 (abfd, address);
+
+      saddend = (bfd_signed_vma) addend;
+
+      if (saddend > 0x7fff || saddend < -0x8000)
+	return bfd_reloc_overflow;
+
+      insn = addend;
+      break;
+
+    case R_V810_GNU_VTINHERIT:
+    case R_V810_GNU_VTENTRY:
+      return bfd_reloc_ok;
+
+    }
+
+  bfd_put_16 (abfd, (bfd_vma) insn, address);
+  return bfd_reloc_ok;
+}
+
+/* Insert the addend into the instruction.  */
+
+static bfd_reloc_status_type
+v810_elf_reloc (bfd *abfd ATTRIBUTE_UNUSED,
+		arelent *reloc,
+		asymbol *symbol,
+		void * data ATTRIBUTE_UNUSED,
+		asection *isection,
+		bfd *obfd,
+		char **err ATTRIBUTE_UNUSED)
+{
+  long relocation;
+
+  /* If there is an output BFD,
+     and the symbol is not a section name (which is only defined at final link time),
+     and either we are not putting the addend into the instruction
+      or the addend is zero, so there is nothing to add into the instruction
+     then just fixup the address and return.  */
+  if (obfd != NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (! reloc->howto->partial_inplace
+	  || reloc->addend == 0))
+    {
+      reloc->address += isection->output_offset;
+      return bfd_reloc_ok;
+    }
+
+  /* Catch relocs involving undefined symbols.  */
+  if (bfd_is_und_section (symbol->section)
+      && (symbol->flags & BSF_WEAK) == 0
+      && obfd == NULL)
+    return bfd_reloc_undefined;
+
+  /* We handle final linking of some relocs ourselves.  */
+
+  /* Is the address of the relocation really within the section?  */
+  if (reloc->address > bfd_get_section_limit (abfd, isection))
+    return bfd_reloc_outofrange;
+
+  /* Work out which section the relocation is targeted at and the
+     initial relocation command value.  */
+
+  if (reloc->howto->pc_relative)
+    return bfd_reloc_ok;
+
+  /* Get symbol value.  (Common symbols are special.)  */
+  if (bfd_is_com_section (symbol->section))
+    relocation = 0;
+  else
+    relocation = symbol->value;
+
+  /* Convert input-section-relative symbol value to absolute + addend.  */
+  relocation += symbol->section->output_section->vma;
+  relocation += symbol->section->output_offset;
+  relocation += reloc->addend;
+
+  reloc->addend = relocation;
+  return bfd_reloc_ok;
+}
+
+/* This function is used for relocs which are only used
+   for relaxing, which the linker should otherwise ignore.  */
+
+static bfd_reloc_status_type
+v810_elf_ignore_reloc (bfd *abfd ATTRIBUTE_UNUSED,
+		       arelent *reloc_entry,
+		       asymbol *symbol ATTRIBUTE_UNUSED,
+		       void * data ATTRIBUTE_UNUSED,
+		       asection *input_section,
+		       bfd *output_bfd,
+		       char **error_message ATTRIBUTE_UNUSED)
+{
+  if (output_bfd != NULL)
+    reloc_entry->address += input_section->output_offset;
+
+  return bfd_reloc_ok;
+}
+/* Note: It is REQUIRED that the 'type' value of each entry
+   in this array match the index of the entry in the array.
+   SeeAlso: RELOC_NUBMER in include/elf/v810.h  */
+static reloc_howto_type v810_elf_howto_table[] =
+{
+  /* This reloc does nothing.  */
+  HOWTO (R_V810_NONE,			/* Type.  */
+	 0,				/* Rightshift.  */
+	 2,				/* Size (0 = byte, 1 = short, 2 = long).  */
+	 32,				/* Bitsize.  */
+	 FALSE,				/* PC_relative.  */
+	 0,				/* Bitpos.  */
+	 complain_overflow_bitfield,	/* Complain_on_overflow.  */
+	 bfd_elf_generic_reloc,		/* Special_function.  */
+	 "R_V810_NONE",			/* Name.  */
+	 FALSE,				/* Partial_inplace.  */
+	 0,				/* Src_mask.  */
+	 0,				/* Dst_mask.  */
+	 FALSE),			/* PCrel_offset.  */
+
+  /* A PC relative 9 bit branch.  */
+  HOWTO (R_V810_9_PCREL,		/* Type.  */
+	 0,				/* Rightshift.  */
+	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
+	 9,				/* Bitsize.  */
+	 TRUE,				/* PC_relative.  */
+	 0,				/* Bitpos.  */
+	 complain_overflow_bitfield,	/* Complain_on_overflow.  */
+	 v810_elf_reloc,		/* Special_function.  */
+	 "R_V810_9_PCREL",		/* Name.  */
+	 FALSE,				/* Partial_inplace.  */
+	 0x00ffffff,			/* Src_mask.  */
+	 0x00ffffff,			/* Dst_mask.  */
+	 TRUE),				/* PCrel_offset.  */
+
+  /* A PC relative 26 bit branch.  */
+  HOWTO (R_V810_26_PCREL,		/* Type.  */
+	 0,				/* Rightshift.  */
+	 2,				/* Size (0 = byte, 1 = short, 2 = long).  */
+	 26,				/* Bitsize.  */
+	 TRUE,				/* PC_relative.  */
+	 0,				/* Bitpos.  */
+	 complain_overflow_signed,	/* Complain_on_overflow.  */
+	 v810_elf_reloc,		/* Special_function.  */
+	 "R_V810_26_PCREL",		/* Name.  */
+	 FALSE,				/* Partial_inplace.  */
+	 0x03ffffff,			/* Src_mask.  */
+	 0x03ffffff,			/* Dst_mask.  */
+	 TRUE),				/* PCrel_offset.  */
+
+  /* High 16 bits of symbol value.  */
+  HOWTO (R_V810_HI16_S,			/* Type.  */
+	 0,				/* Rightshift.  */
+	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
+	 16,				/* Bitsize.  */
+	 FALSE,				/* PC_relative.  */
+	 0,				/* Bitpos.  */
+	 complain_overflow_dont,	/* Complain_on_overflow.  */
+	 v810_elf_reloc,		/* Special_function.  */
+	 "R_V810_HI16_S",		/* Name.  */
+	 FALSE,				/* Partial_inplace.  */
+	 0xffff,			/* Src_mask.  */
+	 0xffff,			/* Dst_mask.  */
+	 FALSE),			/* PCrel_offset.  */
+
+  /* High 16 bits of symbol value.  */
+  HOWTO (R_V810_HI16,			/* Type.  */
+	 0,				/* Rightshift.  */
+	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
+	 16,				/* Bitsize.  */
+	 FALSE,				/* PC_relative.  */
+	 0,				/* Bitpos.  */
+	 complain_overflow_dont,	/* Complain_on_overflow.  */
+	 v810_elf_reloc,		/* Special_function.  */
+	 "R_V810_HI16",			/* Name.  */
+	 FALSE,				/* Partial_inplace.  */
+	 0xffff,			/* Src_mask.  */
+	 0xffff,			/* Dst_mask.  */
+	 FALSE),			/* PCrel_offset.  */
+
+  /* Low 16 bits of symbol value.  */
+  HOWTO (R_V810_LO16,			/* Type.  */
+	 0,				/* Rightshift.  */
+	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
+	 16,				/* Bitsize.  */
+	 FALSE,				/* PC_relative.  */
+	 0,				/* Bitpos.  */
+	 complain_overflow_dont,	/* Complain_on_overflow.  */
+	 v810_elf_reloc,		/* Special_function.  */
+	 "R_V810_LO16",			/* Name.  */
+	 FALSE,				/* Partial_inplace.  */
+	 0xffff,			/* Src_mask.  */
+	 0xffff,			/* Dst_mask.  */
+	 FALSE),			/* PCrel_offset.  */
+
+  /* Simple 32bit reloc.  */
+  HOWTO (R_V810_32,			/* Type.  */
+	 0,				/* Rightshift.  */
+	 2,				/* Size (0 = byte, 1 = short, 2 = long).  */
+	 32,				/* Bitsize.  */
+	 FALSE,				/* PC_relative.  */
+	 0,				/* Bitpos.  */
+	 complain_overflow_dont,	/* Complain_on_overflow.  */
+	 v810_elf_reloc,		/* Special_function.  */
+	 "R_V810_32",			/* Name.  */
+	 FALSE,				/* Partial_inplace.  */
+	 0xffffffff,			/* Src_mask.  */
+	 0xffffffff,			/* Dst_mask.  */
+	 FALSE),			/* PCrel_offset.  */
+
+  /* Simple 16bit reloc.  */
+  HOWTO (R_V810_16,			/* Type.  */
+	 0,				/* Rightshift.  */
+	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
+	 16,				/* Bitsize.  */
+	 FALSE,				/* PC_relative.  */
+	 0,				/* Bitpos.  */
+	 complain_overflow_dont,	/* Complain_on_overflow.  */
+	 bfd_elf_generic_reloc,		/* Special_function.  */
+	 "R_V810_16",			/* Name.  */
+	 FALSE,				/* Partial_inplace.  */
+	 0xffff,			/* Src_mask.  */
+	 0xffff,			/* Dst_mask.  */
+	 FALSE),			/* PCrel_offset.  */
+
+  /* Simple 8bit reloc.	 */
+  HOWTO (R_V810_8,			/* Type.  */
+	 0,				/* Rightshift.  */
+	 0,				/* Size (0 = byte, 1 = short, 2 = long).  */
+	 8,				/* Bitsize.  */
+	 FALSE,				/* PC_relative.  */
+	 0,				/* Bitpos.  */
+	 complain_overflow_dont,	/* Complain_on_overflow.  */
+	 bfd_elf_generic_reloc,		/* Special_function.  */
+	 "R_V810_8",			/* Name.  */
+	 FALSE,				/* Partial_inplace.  */
+	 0xff,				/* Src_mask.  */
+	 0xff,				/* Dst_mask.  */
+	 FALSE),			/* PCrel_offset.  */
+
+  /* 16 bit offset from the short data area pointer.  */
+  HOWTO (R_V810_SDA_16_16_OFFSET,	/* Type.  */
+	 0,				/* Rightshift.  */
+	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
+	 16,				/* Bitsize.  */
+	 FALSE,				/* PC_relative.  */
+	 0,				/* Bitpos.  */
+	 complain_overflow_dont,	/* Complain_on_overflow.  */
+	 v810_elf_reloc,		/* Special_function.  */
+	 "R_V810_SDA_16_16_OFFSET",	/* Name.  */
+	 FALSE,				/* Partial_inplace.  */
+	 0xffff,			/* Src_mask.  */
+	 0xffff,			/* Dst_mask.  */
+	 FALSE),			/* PCrel_offset.  */
+
+  /* 16 bit offset from the zero data area pointer.  */
+  HOWTO (R_V810_ZDA_16_16_OFFSET,	/* Type.  */
+	 0,				/* Rightshift.  */
+	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
+	 16,				/* Bitsize.  */
+	 FALSE,				/* PC_relative.  */
+	 0,				/* Bitpos.  */
+	 complain_overflow_dont,	/* Complain_on_overflow.  */
+	 v810_elf_reloc,		/* Special_function.  */
+	 "R_V810_ZDA_16_16_OFFSET",	/* Name.  */
+	 FALSE,				/* Partial_inplace.  */
+	 0xffff,			/* Src_mask.  */
+	 0xffff,			/* Dst_mask.  */
+	 FALSE),			/* PCrel_offset.  */
+
+
+  /* GNU extension to record C++ vtable hierarchy */
+  HOWTO (R_V810_GNU_VTINHERIT, /* Type.  */
+	 0,                     /* Rightshift.  */
+	 2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
+	 0,                     /* Bitsize.  */
+	 FALSE,                 /* PC_relative.  */
+	 0,                     /* Bitpos.  */
+	 complain_overflow_dont, /* Complain_on_overflow.  */
+	 NULL,                  /* Special_function.  */
+	 "R_V810_GNU_VTINHERIT", /* Name.  */
+	 FALSE,                 /* Partial_inplace.  */
+	 0,                     /* Src_mask.  */
+	 0,                     /* Dst_mask.  */
+	 FALSE),                /* PCrel_offset.  */
+
+  /* GNU extension to record C++ vtable member usage.  */
+  HOWTO (R_V810_GNU_VTENTRY,     /* Type.  */
+	 0,                     /* Rightshift.  */
+	 2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
+	 0,                     /* Bitsize.  */
+	 FALSE,                 /* PC_relative.  */
+	 0,                     /* Bitpos.  */
+	 complain_overflow_dont, /* Complain_on_overflow.  */
+	 _bfd_elf_rel_vtable_reloc_fn,  /* Special_function.  */
+	 "R_V810_GNU_VTENTRY",   /* Name.  */
+	 FALSE,                 /* Partial_inplace.  */
+	 0,                     /* Src_mask.  */
+	 0,                     /* Dst_mask.  */
+	 FALSE),                /* PCrel_offset.  */
+
+  /* Indicates a .longcall pseudo-op.  The compiler will generate a .longcall
+     pseudo-op when it finds a function call which can be relaxed.  */
+  HOWTO (R_V810_LONGCALL,     /* Type.  */
+	 0,                     /* Rightshift.  */
+	 2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
+	 32,                    /* Bitsize.  */
+	 TRUE,                  /* PC_relative.  */
+	 0,                     /* Bitpos.  */
+	 complain_overflow_signed, /* Complain_on_overflow.  */
+	 v810_elf_ignore_reloc, /* Special_function.  */
+	 "R_V810_LONGCALL",     /* Name.  */
+	 FALSE,                 /* Partial_inplace.  */
+	 0,                     /* Src_mask.  */
+	 0,                     /* Dst_mask.  */
+	 TRUE),                 /* PCrel_offset.  */
+
+  /* Indicates a .longjump pseudo-op.  The compiler will generate a
+     .longjump pseudo-op when it finds a branch which can be relaxed.  */
+  HOWTO (R_V810_LONGJUMP,     /* Type.  */
+	 0,                     /* Rightshift.  */
+	 2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
+	 32,                    /* Bitsize.  */
+	 TRUE,                  /* PC_relative.  */
+	 0,                     /* Bitpos.  */
+	 complain_overflow_signed, /* Complain_on_overflow.  */
+	 v810_elf_ignore_reloc, /* Special_function.  */
+	 "R_V810_LONGJUMP",     /* Name.  */
+	 FALSE,                 /* Partial_inplace.  */
+	 0,                     /* Src_mask.  */
+	 0,                     /* Dst_mask.  */
+	 TRUE),                 /* PCrel_offset.  */
+
+  HOWTO (R_V810_ALIGN,        /* Type.  */
+	 0,                     /* Rightshift.  */
+	 1,                     /* Size (0 = byte, 1 = short, 2 = long).  */
+	 0,                     /* Bitsize.  */
+	 FALSE,                 /* PC_relative.  */
+	 0,                     /* Bitpos.  */
+	 complain_overflow_unsigned, /* Complain_on_overflow.  */
+	 v810_elf_ignore_reloc, /* Special_function.  */
+	 "R_V810_ALIGN",        /* Name.  */
+	 FALSE,                 /* Partial_inplace.  */
+	 0,                     /* Src_mask.  */
+	 0,                     /* Dst_mask.  */
+	 TRUE),                 /* PCrel_offset.  */
+
+};
+
+/* Map BFD reloc types to V810 ELF reloc types.  */
+
+struct v810_elf_reloc_map
+{
+  /* BFD_RELOC_V810_CALLT_16_16_OFFSET is 258, which will not fix in an
+     unsigned char.  */
+  bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned int elf_reloc_val;
+};
+
+static const struct v810_elf_reloc_map v810_elf_reloc_map[] =
+{
+  { BFD_RELOC_NONE,                        R_V810_NONE                   },
+  { BFD_RELOC_V810_9_PCREL,                R_V810_9_PCREL                },
+  { BFD_RELOC_V810_26_PCREL,               R_V810_26_PCREL               },
+  { BFD_RELOC_HI16_S,                      R_V810_HI16_S                 },
+  { BFD_RELOC_HI16,                        R_V810_HI16                   },
+  { BFD_RELOC_LO16,                        R_V810_LO16                   },
+  { BFD_RELOC_32,                          R_V810_32                     },
+  { BFD_RELOC_16,                          R_V810_16                     },
+  { BFD_RELOC_8,                           R_V810_8                      },
+  { BFD_RELOC_V810_SDA_16_16_OFFSET,       R_V810_SDA_16_16_OFFSET       },
+  { BFD_RELOC_V810_ZDA_16_16_OFFSET,       R_V810_ZDA_16_16_OFFSET       },
+  { BFD_RELOC_VTABLE_INHERIT,              R_V810_GNU_VTINHERIT          },
+  { BFD_RELOC_VTABLE_ENTRY,                R_V810_GNU_VTENTRY            },
+  { BFD_RELOC_V810_LONGCALL,               R_V810_LONGCALL               },
+  { BFD_RELOC_V810_LONGJUMP,               R_V810_LONGJUMP               },
+  { BFD_RELOC_V810_ALIGN,                  R_V810_ALIGN                  },
+};
+
+/* Map a bfd relocation into the appropriate howto structure.  */
+
+static reloc_howto_type *
+v810_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			    bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+
+  for (i = ARRAY_SIZE (v810_elf_reloc_map); i --;)
+    if (v810_elf_reloc_map[i].bfd_reloc_val == code)
+      {
+	unsigned int elf_reloc_val = v810_elf_reloc_map[i].elf_reloc_val;
+
+	BFD_ASSERT (v810_elf_howto_table[elf_reloc_val].type == elf_reloc_val);
+
+	return v810_elf_howto_table + elf_reloc_val;
+      }
+
+  return NULL;
+}
+
+static reloc_howto_type *
+v810_elf_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			    const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0;
+       i < sizeof (v810_elf_howto_table) / sizeof (v810_elf_howto_table[0]);
+       i++)
+    if (v810_elf_howto_table[i].name != NULL
+	&& strcasecmp (v810_elf_howto_table[i].name, r_name) == 0)
+      return &v810_elf_howto_table[i];
+
+  return NULL;
+}
+
+/* Set the howto pointer for an V810 ELF reloc.  */
+
+static void
+v810_elf_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
+			    arelent *cache_ptr,
+			    Elf_Internal_Rela *dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  BFD_ASSERT (r_type < (unsigned int) R_V810_max);
+  cache_ptr->howto = &v810_elf_howto_table[r_type];
+}
+
+/* Set the howto pointer for a V810 ELF reloc (type RELA).  */
+
+static void
+v810_elf_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
+			     arelent * cache_ptr,
+			     Elf_Internal_Rela *dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  BFD_ASSERT (r_type < (unsigned int) R_V810_max);
+  cache_ptr->howto = &v810_elf_howto_table[r_type];
+}
+
+static bfd_boolean
+v810_elf_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED, const char *name)
+{
+  return (   (name[0] == '.' && (name[1] == 'L' || name[1] == '.'))
+	  || (name[0] == '_' &&  name[1] == '.' && name[2] == 'L' && name[3] == '_'));
+}
+
+/* We overload some of the bfd_reloc error codes for own purposes.  */
+#define bfd_reloc_gp_not_found		bfd_reloc_other
+#define bfd_reloc_ep_not_found		bfd_reloc_continue
+#define bfd_reloc_ctbp_not_found	(bfd_reloc_dangerous + 1)
+
+/* Perform a relocation as part of a final link.  */
+
+static bfd_reloc_status_type
+v810_elf_final_link_relocate (reloc_howto_type *howto,
+			      bfd *input_bfd,
+			      bfd *output_bfd ATTRIBUTE_UNUSED,
+			      asection *input_section,
+			      bfd_byte *contents,
+			      bfd_vma offset,
+			      bfd_vma value,
+			      bfd_vma addend,
+			      struct bfd_link_info *info,
+			      asection *sym_sec,
+			      int is_local ATTRIBUTE_UNUSED)
+{
+  unsigned int r_type = howto->type;
+  bfd_byte *hit_data = contents + offset;
+
+  /* Adjust the value according to the relocation.  */
+  switch (r_type)
+    {
+    case R_V810_9_PCREL:
+      value -= (input_section->output_section->vma
+		+ input_section->output_offset);
+      value -= offset;
+      break;
+
+    case R_V810_26_PCREL:
+      value -= (input_section->output_section->vma
+		+ input_section->output_offset
+		+ offset);
+      break;
+
+    case R_V810_HI16_S:
+    case R_V810_HI16:
+    case R_V810_LO16:
+    case R_V810_16:
+    case R_V810_32:
+    case R_V810_8:
+      break;
+
+    case R_V810_ZDA_16_16_OFFSET:
+      if (sym_sec == NULL)
+	return bfd_reloc_undefined;
+
+      value -= sym_sec->output_section->vma;
+      break;
+
+    case R_V810_SDA_16_16_OFFSET:
+      {
+	unsigned long                gp;
+	struct bfd_link_hash_entry * h;
+
+	if (sym_sec == NULL)
+	  return bfd_reloc_undefined;
+
+	/* Get the value of __gp.  */
+	h = bfd_link_hash_lookup (info->hash, "__gp", FALSE, FALSE, TRUE);
+	if (h == NULL
+	    || h->type != bfd_link_hash_defined)
+	  return bfd_reloc_gp_not_found;
+
+	gp = (h->u.def.value
+	      + h->u.def.section->output_section->vma
+	      + h->u.def.section->output_offset);
+
+	value -= sym_sec->output_section->vma;
+	value -= (gp - sym_sec->output_section->vma);
+      }
+    break;
+
+    case R_V810_NONE:
+    case R_V810_GNU_VTINHERIT:
+    case R_V810_GNU_VTENTRY:
+    case R_V810_LONGCALL:
+    case R_V810_LONGJUMP:
+    case R_V810_ALIGN:
+      return bfd_reloc_ok;
+
+    default:
+      return bfd_reloc_notsupported;
+    }
+
+  /* Perform the relocation.  */
+  return v810_elf_perform_relocation (input_bfd, r_type, value + addend, hit_data);
+}
+
+/* Relocate an V810 ELF section.  */
+
+static bfd_boolean
+v810_elf_relocate_section (bfd *output_bfd,
+			   struct bfd_link_info *info,
+			   bfd *input_bfd,
+			   asection *input_section,
+			   bfd_byte *contents,
+			   Elf_Internal_Rela *relocs,
+			   Elf_Internal_Sym *local_syms,
+			   asection **local_sections)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  Elf_Internal_Rela *rel;
+  Elf_Internal_Rela *relend;
+
+  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (input_bfd);
+
+  /* Reset the list of remembered HI16S relocs to empty.  */
+  free_hi16s     = previous_hi16s;
+  previous_hi16s = NULL;
+  hi16s_counter  = 0;
+
+  rel    = relocs;
+  relend = relocs + input_section->reloc_count;
+  for (; rel < relend; rel++)
+    {
+      int r_type;
+      reloc_howto_type *howto;
+      unsigned long r_symndx;
+      Elf_Internal_Sym *sym;
+      asection *sec;
+      struct elf_link_hash_entry *h;
+      bfd_vma relocation;
+      bfd_reloc_status_type r;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      r_type   = ELF32_R_TYPE (rel->r_info);
+
+      if (r_type == R_V810_GNU_VTENTRY
+          || r_type == R_V810_GNU_VTINHERIT)
+        continue;
+
+      howto = v810_elf_howto_table + r_type;
+      h = NULL;
+      sym = NULL;
+      sec = NULL;
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  sym = local_syms + r_symndx;
+	  sec = local_sections[r_symndx];
+	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
+	}
+      else
+	{
+	  bfd_boolean unresolved_reloc, warned;
+
+	  /* Note - this check is delayed until now as it is possible and
+	     valid to have a file without any symbols but with relocs that
+	     can be processed.  */
+	  if (sym_hashes == NULL)
+	    {
+	      info->callbacks->warning
+		(info, "no hash table available",
+		 NULL, input_bfd, input_section, (bfd_vma) 0);
+
+	      return FALSE;
+	    }
+
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, sym_hashes,
+				   h, sec, relocation,
+				   unresolved_reloc, warned);
+	}
+
+      if (sec != NULL && discarded_section (sec))
+	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+					 rel, 1, relend, howto, 0, contents);
+
+      if (info->relocatable)
+	continue;
+
+      /* FIXME: We should use the addend, but the COFF relocations don't.  */
+      r = v810_elf_final_link_relocate (howto, input_bfd, output_bfd,
+					input_section,
+					contents, rel->r_offset,
+					relocation, rel->r_addend,
+					info, sec, h == NULL);
+
+      if (r != bfd_reloc_ok)
+	{
+	  const char * name;
+	  const char * msg = NULL;
+
+	  if (h != NULL)
+	    name = h->root.root.string;
+	  else
+	    {
+	      name = (bfd_elf_string_from_elf_section
+		      (input_bfd, symtab_hdr->sh_link, sym->st_name));
+	      if (name == NULL || *name == '\0')
+		name = bfd_section_name (input_bfd, sec);
+	    }
+
+	  switch ((int) r)
+	    {
+	    case bfd_reloc_overflow:
+	      if (! ((*info->callbacks->reloc_overflow)
+		     (info, (h ? &h->root : NULL), name, howto->name,
+		      (bfd_vma) 0, input_bfd, input_section,
+		      rel->r_offset)))
+		return FALSE;
+	      break;
+
+	    case bfd_reloc_undefined:
+	      if (! ((*info->callbacks->undefined_symbol)
+		     (info, name, input_bfd, input_section,
+		      rel->r_offset, TRUE)))
+		return FALSE;
+	      break;
+
+	    case bfd_reloc_outofrange:
+	      msg = _("internal error: out of range error");
+	      goto common_error;
+
+	    case bfd_reloc_notsupported:
+	      msg = _("internal error: unsupported relocation error");
+	      goto common_error;
+
+	    case bfd_reloc_dangerous:
+	      msg = _("internal error: dangerous relocation");
+	      goto common_error;
+
+	    case bfd_reloc_gp_not_found:
+	      msg = _("could not locate special linker symbol __gp");
+	      goto common_error;
+
+	    case bfd_reloc_ep_not_found:
+	      msg = _("could not locate special linker symbol __ep");
+	      goto common_error;
+
+	    case bfd_reloc_ctbp_not_found:
+	      msg = _("could not locate special linker symbol __ctbp");
+	      goto common_error;
+
+	    default:
+	      msg = _("internal error: unknown error");
+	      /* fall through */
+
+	    common_error:
+	      if (!((*info->callbacks->warning)
+		    (info, msg, name, input_bfd, input_section,
+		     rel->r_offset)))
+		return FALSE;
+	      break;
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+static asection *
+v810_elf_gc_mark_hook (asection *sec,
+		       struct bfd_link_info *info,
+		       Elf_Internal_Rela *rel,
+		       struct elf_link_hash_entry *h,
+		       Elf_Internal_Sym *sym)
+{
+  if (h != NULL)
+    switch (ELF32_R_TYPE (rel->r_info))
+      {
+      case R_V810_GNU_VTINHERIT:
+      case R_V810_GNU_VTENTRY:
+	return NULL;
+      }
+
+  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
+}
+
+/* Set the right machine number.  */
+
+static bfd_boolean
+v810_elf_object_p (bfd *abfd)
+{
+  switch (elf_elfheader (abfd)->e_flags & EF_V810_ARCH)
+    {
+    default:
+    case E_V810_ARCH:
+      bfd_default_set_arch_mach (abfd, bfd_arch_v810, bfd_mach_v810);
+      break;
+    case E_V830_ARCH:
+      bfd_default_set_arch_mach (abfd, bfd_arch_v810, bfd_mach_v830);
+      break;
+    }
+  return TRUE;
+}
+
+/* Store the machine number in the flags field.  */
+
+static void
+v810_elf_final_write_processing (bfd *abfd,
+				 bfd_boolean linker ATTRIBUTE_UNUSED)
+{
+  unsigned long val;
+
+  switch (bfd_get_mach (abfd))
+    {
+    default:
+    case bfd_mach_v810:   val = E_V810_ARCH; break;
+    case bfd_mach_v830:   val = E_V830_ARCH; break;
+    }
+
+  elf_elfheader (abfd)->e_flags &=~ EF_V810_ARCH;
+  elf_elfheader (abfd)->e_flags |= val;
+}
+
+/* Function to keep V810 specific file flags.  */
+
+static bfd_boolean
+v810_elf_set_private_flags (bfd *abfd, flagword flags)
+{
+  BFD_ASSERT (!elf_flags_init (abfd)
+	      || elf_elfheader (abfd)->e_flags == flags);
+
+  elf_elfheader (abfd)->e_flags = flags;
+  elf_flags_init (abfd) = TRUE;
+  return TRUE;
+}
+
+/* Merge backend specific data from an object file
+   to the output object file when linking.  */
+
+static bfd_boolean
+v810_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
+{
+  flagword out_flags;
+  flagword in_flags;
+
+  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
+      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
+    return TRUE;
+
+  in_flags = elf_elfheader (ibfd)->e_flags;
+  out_flags = elf_elfheader (obfd)->e_flags;
+
+  if (! elf_flags_init (obfd))
+    {
+      /* If the input is the default architecture then do not
+	 bother setting the flags for the output architecture,
+	 instead allow future merges to do this.  If no future
+	 merges ever set these flags then they will retain their
+	 unitialised values, which surprise surprise, correspond
+	 to the default values.  */
+      if (bfd_get_arch_info (ibfd)->the_default)
+	return TRUE;
+
+      elf_flags_init (obfd) = TRUE;
+      elf_elfheader (obfd)->e_flags = in_flags;
+
+      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
+	  && bfd_get_arch_info (obfd)->the_default)
+	return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));
+
+      return TRUE;
+    }
+
+  /* Check flag compatibility.  */
+  if (in_flags == out_flags)
+    return TRUE;
+
+  if ((in_flags & EF_V810_ARCH) != (out_flags & EF_V810_ARCH)
+      && (in_flags & EF_V810_ARCH) != E_V810_ARCH)
+    {
+      _bfd_error_handler (_("%B: Architecture mismatch with previous modules"),
+			  ibfd);
+    }
+
+  return TRUE;
+}
+
+/* Display the flags field.  */
+
+static bfd_boolean
+v810_elf_print_private_bfd_data (bfd *abfd, void * ptr)
+{
+  FILE * file = (FILE *) ptr;
+
+  BFD_ASSERT (abfd != NULL && ptr != NULL);
+
+  _bfd_elf_print_private_bfd_data (abfd, ptr);
+
+  /* xgettext:c-format.  */
+  fprintf (file, _("private flags = %lx: "), elf_elfheader (abfd)->e_flags);
+
+  switch (elf_elfheader (abfd)->e_flags & EF_V810_ARCH)
+    {
+    default:
+    case E_V810_ARCH: fprintf (file, _("v810 architecture")); break;
+    case E_V830_ARCH: fprintf (file, _("v830 architecture")); break;
+    }
+
+  fputc ('\n', file);
+
+  return TRUE;
+}
+
+/* V810 ELF uses four common sections.  One is the usual one, and the
+   others are for (small) objects in one of the special data areas:
+   small, tiny and zero.  All the objects are kept together, and then
+   referenced via the gp register, the ep register or the r0 register
+   respectively, which yields smaller, faster assembler code.  This
+   approach is copied from elf32-mips.c.  */
+
+static asection  v810_elf_scom_section;
+static asymbol   v810_elf_scom_symbol;
+static asymbol * v810_elf_scom_symbol_ptr;
+static asection  v810_elf_zcom_section;
+static asymbol   v810_elf_zcom_symbol;
+static asymbol * v810_elf_zcom_symbol_ptr;
+
+/* Given a BFD section, try to locate the
+   corresponding ELF section index.  */
+
+static bfd_boolean
+v810_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
+				   asection *sec,
+				   int *retval)
+{
+  if (strcmp (bfd_get_section_name (abfd, sec), ".scommon") == 0)
+    *retval = SHN_V810_SCOMMON;
+  else if (strcmp (bfd_get_section_name (abfd, sec), ".zcommon") == 0)
+    *retval = SHN_V810_ZCOMMON;
+  else
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Handle the special V810 section numbers that a symbol may use.  */
+
+static void
+v810_elf_symbol_processing (bfd *abfd, asymbol *asym)
+{
+  elf_symbol_type * elfsym = (elf_symbol_type *) asym;
+  unsigned int indx;
+
+  indx = elfsym->internal_elf_sym.st_shndx;
+
+  /* If the section index is an "ordinary" index, then it may
+     refer to a v810 specific section created by the assembler.
+     Check the section's type and change the index it matches.
+
+     FIXME: Should we alter the st_shndx field as well ?  */
+
+  if (indx < elf_numsections (abfd))
+    switch (elf_elfsections (abfd)[indx]->sh_type)
+      {
+      case SHT_V810_SCOMMON:
+	indx = SHN_V810_SCOMMON;
+	break;
+
+      case SHT_V810_ZCOMMON:
+	indx = SHN_V810_ZCOMMON;
+	break;
+
+      default:
+	break;
+      }
+
+  switch (indx)
+    {
+    case SHN_V810_SCOMMON:
+      if (v810_elf_scom_section.name == NULL)
+	{
+	  /* Initialize the small common section.  */
+	  v810_elf_scom_section.name           = ".scommon";
+	  v810_elf_scom_section.flags          = SEC_IS_COMMON | SEC_ALLOC | SEC_DATA;
+	  v810_elf_scom_section.output_section = & v810_elf_scom_section;
+	  v810_elf_scom_section.symbol         = & v810_elf_scom_symbol;
+	  v810_elf_scom_section.symbol_ptr_ptr = & v810_elf_scom_symbol_ptr;
+	  v810_elf_scom_symbol.name            = ".scommon";
+	  v810_elf_scom_symbol.flags           = BSF_SECTION_SYM;
+	  v810_elf_scom_symbol.section         = & v810_elf_scom_section;
+	  v810_elf_scom_symbol_ptr             = & v810_elf_scom_symbol;
+	}
+      asym->section = & v810_elf_scom_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+
+    case SHN_V810_ZCOMMON:
+      if (v810_elf_zcom_section.name == NULL)
+	{
+	  /* Initialize the zcommon section.  */
+	  v810_elf_zcom_section.name           = ".zcommon";
+	  v810_elf_zcom_section.flags          = SEC_IS_COMMON;
+	  v810_elf_zcom_section.output_section = & v810_elf_zcom_section;
+	  v810_elf_zcom_section.symbol         = & v810_elf_zcom_symbol;
+	  v810_elf_zcom_section.symbol_ptr_ptr = & v810_elf_zcom_symbol_ptr;
+	  v810_elf_zcom_symbol.name            = ".zcommon";
+	  v810_elf_zcom_symbol.flags           = BSF_SECTION_SYM;
+	  v810_elf_zcom_symbol.section         = & v810_elf_zcom_section;
+	  v810_elf_zcom_symbol_ptr             = & v810_elf_zcom_symbol;
+	}
+      asym->section = & v810_elf_zcom_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+    }
+}
+
+/* Hook called by the linker routine which adds symbols from an object
+   file.  We must handle the special v810 section numbers here.  */
+
+static bfd_boolean
+v810_elf_add_symbol_hook (bfd *abfd,
+			  struct bfd_link_info *info ATTRIBUTE_UNUSED,
+			  Elf_Internal_Sym *sym,
+			  const char **namep ATTRIBUTE_UNUSED,
+			  flagword *flagsp ATTRIBUTE_UNUSED,
+			  asection **secp,
+			  bfd_vma *valp)
+{
+  unsigned int indx = sym->st_shndx;
+
+  /* If the section index is an "ordinary" index, then it may
+     refer to a v810 specific section created by the assembler.
+     Check the section's type and change the index it matches.
+
+     FIXME: Should we alter the st_shndx field as well ?  */
+
+  if (indx < elf_numsections (abfd))
+    switch (elf_elfsections (abfd)[indx]->sh_type)
+      {
+      case SHT_V810_SCOMMON:
+	indx = SHN_V810_SCOMMON;
+	break;
+
+      case SHT_V810_ZCOMMON:
+	indx = SHN_V810_ZCOMMON;
+	break;
+
+      default:
+	break;
+      }
+
+  switch (indx)
+    {
+    case SHN_V810_SCOMMON:
+      *secp = bfd_make_section_old_way (abfd, ".scommon");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+
+    case SHN_V810_ZCOMMON:
+      *secp = bfd_make_section_old_way (abfd, ".zcommon");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+    }
+
+  return TRUE;
+}
+
+static int
+v810_elf_link_output_symbol_hook (struct bfd_link_info *info ATTRIBUTE_UNUSED,
+				  const char *name ATTRIBUTE_UNUSED,
+				  Elf_Internal_Sym *sym,
+				  asection *input_sec,
+				  struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
+{
+  /* If we see a common symbol, which implies a relocatable link, then
+     if a symbol was in a special common section in an input file, mark
+     it as a special common in the output file.  */
+
+  if (sym->st_shndx == SHN_COMMON)
+    {
+      if (strcmp (input_sec->name, ".scommon") == 0)
+	sym->st_shndx = SHN_V810_SCOMMON;
+      else if (strcmp (input_sec->name, ".zcommon") == 0)
+	sym->st_shndx = SHN_V810_ZCOMMON;
+    }
+
+  /* The price we pay for using h->other unused bits as flags in the
+     linker is cleaning up after ourselves.  */
+
+  sym->st_other &= ~(V810_OTHER_SDA | V810_OTHER_ZDA | V810_OTHER_ERROR);
+
+  return 1;
+}
+
+static bfd_boolean
+v810_elf_section_from_shdr (bfd *abfd,
+			    Elf_Internal_Shdr *hdr,
+			    const char *name,
+			    int shindex)
+{
+  /* There ought to be a place to keep ELF backend specific flags, but
+     at the moment there isn't one.  We just keep track of the
+     sections by their name, instead.  */
+
+  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
+    return FALSE;
+
+  switch (hdr->sh_type)
+    {
+    case SHT_V810_SCOMMON:
+    case SHT_V810_ZCOMMON:
+      if (! bfd_set_section_flags (abfd, hdr->bfd_section,
+				   (bfd_get_section_flags (abfd,
+							   hdr->bfd_section)
+				    | SEC_IS_COMMON)))
+	return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* Set the correct type for a V810 ELF section.  We do this
+   by the section name, which is a hack, but ought to work.  */
+
+static bfd_boolean
+v810_elf_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,
+			Elf_Internal_Shdr *hdr,
+			asection *sec)
+{
+  const char * name;
+
+  name = bfd_get_section_name (abfd, sec);
+
+  if (strcmp (name, ".scommon") == 0)
+    hdr->sh_type = SHT_V810_SCOMMON;
+  else if (strcmp (name, ".zcommon") == 0)
+    hdr->sh_type = SHT_V810_ZCOMMON;
+
+  return TRUE;
+}
+
+/* Delete some bytes from a section while relaxing.  */
+
+static bfd_boolean
+v810_elf_relax_delete_bytes (bfd *abfd,
+			     asection *sec,
+			     bfd_vma addr,
+			     bfd_vma toaddr,
+			     int count)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf32_External_Sym *extsyms;
+  Elf32_External_Sym *esym;
+  Elf32_External_Sym *esymend;
+  int sym_index;
+  unsigned int sec_shndx;
+  bfd_byte *contents;
+  Elf_Internal_Rela *irel;
+  Elf_Internal_Rela *irelend;
+  struct elf_link_hash_entry *sym_hash;
+  Elf_Internal_Shdr *shndx_hdr;
+  Elf_External_Sym_Shndx *shndx;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
+
+  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
+
+  contents = elf_section_data (sec)->this_hdr.contents;
+
+  /* The deletion must stop at the next ALIGN reloc for an alignment
+     power larger than the number of bytes we are deleting.  */
+
+  /* Actually delete the bytes.  */
+#if (DEBUG_RELAX & 2)
+  fprintf (stderr, "relax_delete: contents: sec: %s  %p .. %p %x\n",
+	   sec->name, addr, toaddr, count );
+#endif
+  memmove (contents + addr, contents + addr + count,
+	   toaddr - addr - count);
+  memset (contents + toaddr-count, 0, count);
+
+  /* Adjust all the relocs.  */
+  irel = elf_section_data (sec)->relocs;
+  irelend = irel + sec->reloc_count;
+  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
+  shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
+
+  for (; irel < irelend; irel++)
+    {
+      bfd_vma raddr, paddr, symval;
+      Elf_Internal_Sym isym;
+
+      /* Get the new reloc address.  */
+      raddr = irel->r_offset;
+      if ((raddr >= (addr + count) && raddr < toaddr))
+	irel->r_offset -= count;
+
+      if (raddr >= addr && raddr < addr + count)
+	{
+	  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
+				       (int) R_V810_NONE);
+	  continue;
+	}
+
+      if (ELF32_R_TYPE (irel->r_info) == (int) R_V810_ALIGN)
+	continue;
+
+      bfd_elf32_swap_symbol_in (abfd,
+				extsyms + ELF32_R_SYM (irel->r_info),
+				shndx ? shndx + ELF32_R_SYM (irel->r_info) : NULL,
+				& isym);
+
+      if (isym.st_shndx != sec_shndx)
+	continue;
+
+      /* Get the value of the symbol referred to by the reloc.  */
+      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
+	{
+	  symval = isym.st_value;
+#if (DEBUG_RELAX & 2)
+	  {
+	    char * name = bfd_elf_string_from_elf_section
+	                   (abfd, symtab_hdr->sh_link, isym.st_name);
+	    fprintf (stderr,
+	       "relax_delete: local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n",
+	       sec->name, name, isym.st_name,
+	       sec->output_section->vma, sec->output_offset,
+	       isym.st_value, irel->r_addend);
+	  }
+#endif
+	}
+      else
+	{
+	  unsigned long indx;
+	  struct elf_link_hash_entry * h;
+
+	  /* An external symbol.  */
+	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
+
+	  h = elf_sym_hashes (abfd) [indx];
+	  BFD_ASSERT (h != NULL);
+
+	  symval = h->root.u.def.value;
+#if (DEBUG_RELAX & 2)
+	  fprintf (stderr,
+		   "relax_delete: defined: sec: %s, name: %s, value: %x + %x + %x addend %x\n",
+		   sec->name, h->root.root.string, h->root.u.def.value,
+		   sec->output_section->vma, sec->output_offset, irel->r_addend);
+#endif
+	}
+
+      paddr = symval + irel->r_addend;
+
+      if ( (symval >= addr + count && symval < toaddr)
+	  && (paddr < addr + count || paddr >= toaddr))
+	irel->r_addend += count;
+      else if (    (symval < addr + count || symval >= toaddr)
+	        && (paddr >= addr + count && paddr < toaddr))
+	irel->r_addend -= count;
+    }
+
+  /* Adjust the local symbols defined in this section.  */
+  esym = extsyms;
+  esymend = esym + symtab_hdr->sh_info;
+
+  for (; esym < esymend; esym++, shndx = (shndx ? shndx + 1 : NULL))
+    {
+      Elf_Internal_Sym isym;
+
+      bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);
+
+      if (isym.st_shndx == sec_shndx
+	  && isym.st_value >= addr + count
+	  && isym.st_value < toaddr)
+	{
+	  isym.st_value -= count;
+
+	  if (isym.st_value + isym.st_size >= toaddr)
+	    isym.st_size += count;
+
+	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
+	}
+      else if (isym.st_shndx == sec_shndx
+	       && isym.st_value < addr + count)
+	{
+	  if (isym.st_value+isym.st_size >= addr + count
+	      && isym.st_value+isym.st_size < toaddr)
+	    isym.st_size -= count;
+
+	  if (isym.st_value >= addr
+	      && isym.st_value <  addr + count)
+	    isym.st_value = addr;
+
+	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
+	}
+    }
+
+  /* Now adjust the global symbols defined in this section.  */
+  esym = extsyms + symtab_hdr->sh_info;
+  esymend = extsyms + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym));
+
+  for (sym_index = 0; esym < esymend; esym ++, sym_index ++)
+    {
+      Elf_Internal_Sym isym;
+
+      bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);
+      sym_hash = elf_sym_hashes (abfd) [sym_index];
+
+      if (isym.st_shndx == sec_shndx
+	  && ((sym_hash)->root.type == bfd_link_hash_defined
+	      || (sym_hash)->root.type == bfd_link_hash_defweak)
+	  && (sym_hash)->root.u.def.section == sec
+	  && (sym_hash)->root.u.def.value >= addr + count
+	  && (sym_hash)->root.u.def.value < toaddr)
+	{
+	  if ((sym_hash)->root.u.def.value + isym.st_size >= toaddr)
+	    {
+	      isym.st_size += count;
+	      bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
+	    }
+
+	  (sym_hash)->root.u.def.value -= count;
+	}
+      else if (isym.st_shndx == sec_shndx
+	       && ((sym_hash)->root.type == bfd_link_hash_defined
+		   || (sym_hash)->root.type == bfd_link_hash_defweak)
+	       && (sym_hash)->root.u.def.section == sec
+	       && (sym_hash)->root.u.def.value < addr + count)
+	{
+	  if ((sym_hash)->root.u.def.value+isym.st_size >= addr + count
+	      && (sym_hash)->root.u.def.value+isym.st_size < toaddr)
+	    isym.st_size -= count;
+
+	  if ((sym_hash)->root.u.def.value >= addr
+	      && (sym_hash)->root.u.def.value < addr + count)
+	    (sym_hash)->root.u.def.value = addr;
+
+	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
+	}
+
+      if (shndx)
+	++ shndx;
+    }
+
+  return TRUE;
+}
+
+#define NOP_OPCODE 	(0x9a00)
+#define MOVHI	    	0xbc00				/* 4byte.  */
+#define MOVHI_MASK  	0xfc00
+#define MOVHI_R1(insn)	((insn) & 0x1f)			/* 4byte.  */
+#define MOVHI_R2(insn)	((insn) >> 5)
+#define MOVEA	    	0xa000				/* 2byte.  */
+#define MOVEA_MASK  	0xfc00
+#define MOVEA_R1(insn)	((insn) & 0x1f)
+#define MOVEA_R2(insn)	((insn) >> 5)
+#define JAL_4	    	0x0004ac00				/* 4byte.  */
+#define JAL_4_MASK 	0xFFFFFFFF
+#define ADD_I       	0x4400					/* 2byte.  */
+#define ADD_I_MASK  	0xfc00
+#define ADD_I5(insn)	((((insn) & 0x001f) << 11) >> 11)	/* 2byte.  */
+#define ADD_R2(insn)	((insn) >> 5)
+#define JMP_R	    	0x1800					/* 2byte.  */
+#define JMP_R_MASK 	0xFFE0
+#define JMP_R1(insn)	((insn) & 0x1f)
+
+static bfd_boolean
+v810_elf_relax_section (bfd *abfd,
+			asection *sec,
+			struct bfd_link_info *link_info,
+			bfd_boolean *again)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Rela *internal_relocs;
+  Elf_Internal_Rela *irel;
+  Elf_Internal_Rela *irelend;
+  Elf_Internal_Rela *irelalign = NULL;
+  Elf_Internal_Sym *isymbuf = NULL;
+  bfd_byte *contents = NULL;
+  bfd_vma addr = 0;
+  bfd_vma toaddr;
+  int align_pad_size = 0;
+  bfd_boolean result = TRUE;
+
+  *again = FALSE;
+
+  if (link_info->relocatable
+      || (sec->flags & SEC_RELOC) == 0
+      || sec->reloc_count == 0)
+    return TRUE;
+
+  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;
+
+  internal_relocs = (_bfd_elf_link_read_relocs
+		     (abfd, sec, NULL, NULL, link_info->keep_memory));
+  if (internal_relocs == NULL)
+    goto error_return;
+
+  irelend = internal_relocs + sec->reloc_count;
+
+  while (addr < sec->size)
+    {
+      toaddr = sec->size;
+
+      for (irel = internal_relocs; irel < irelend; irel ++)
+	if (ELF32_R_TYPE (irel->r_info) == (int) R_V810_ALIGN
+	    && irel->r_offset > addr
+	    && irel->r_offset < toaddr)
+	  toaddr = irel->r_offset;
+
+#ifdef DEBUG_RELAX
+      fprintf (stderr, "relax region 0x%x to 0x%x align pad %d\n",
+	       addr, toaddr, align_pad_size);
+#endif
+      if (irelalign)
+	{
+	  bfd_vma alignto;
+	  bfd_vma alignmoveto;
+
+	  alignmoveto = BFD_ALIGN (addr - align_pad_size, 1 << irelalign->r_addend);
+	  alignto = BFD_ALIGN (addr, 1 << irelalign->r_addend);
+
+	  if (alignmoveto < alignto)
+	    {
+	      unsigned int i;
+
+	      align_pad_size = alignto - alignmoveto;
+#ifdef DEBUG_RELAX
+	      fprintf (stderr, "relax move region 0x%x to 0x%x delete size 0x%x\n",
+		       alignmoveto, toaddr, align_pad_size);
+#endif
+	      if (!v810_elf_relax_delete_bytes (abfd, sec, alignmoveto,
+						toaddr, align_pad_size))
+		goto error_return;
+
+	      for (i  = BFD_ALIGN (toaddr - align_pad_size, 1);
+		   (i + 1) < toaddr; i += 2)
+		bfd_put_16 (abfd, NOP_OPCODE, contents + i);
+
+	      addr = alignmoveto;
+	    }
+	  else
+	    align_pad_size = 0;
+	}
+
+      for (irel = internal_relocs; irel < irelend; irel++)
+	{
+	  bfd_vma laddr;
+	  bfd_vma addend;
+	  bfd_vma symval;
+	  int insn[5];
+	  int no_match = -1;
+	  Elf_Internal_Rela *hi_irelfn;
+	  Elf_Internal_Rela *lo_irelfn;
+	  Elf_Internal_Rela *irelcall;
+	  bfd_signed_vma foff;
+
+	  if (! (irel->r_offset >= addr && irel->r_offset < toaddr
+		 && (ELF32_R_TYPE (irel->r_info) == (int) R_V810_LONGCALL
+		     || ELF32_R_TYPE (irel->r_info) == (int) R_V810_LONGJUMP)))
+	    continue;
+
+#ifdef DEBUG_RELAX
+	  fprintf (stderr, "relax check r_info 0x%x r_offset 0x%x r_addend 0x%x\n",
+		   irel->r_info,
+		   irel->r_offset,
+		   irel->r_addend );
+#endif
+
+	  /* Get the section contents.  */
+	  if (contents == NULL)
+	    {
+	      if (elf_section_data (sec)->this_hdr.contents != NULL)
+		contents = elf_section_data (sec)->this_hdr.contents;
+	      else
+		{
+		  if (! bfd_malloc_and_get_section (abfd, sec, &contents))
+		    goto error_return;
+		}
+	    }
+
+	  /* Read this BFD's local symbols if we haven't done so already.  */
+	  if (isymbuf == NULL && symtab_hdr->sh_info != 0)
+	    {
+	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
+	      if (isymbuf == NULL)
+		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
+						symtab_hdr->sh_info, 0,
+						NULL, NULL, NULL);
+	      if (isymbuf == NULL)
+		goto error_return;
+	    }
+
+	  laddr = irel->r_offset;
+
+	  if (ELF32_R_TYPE (irel->r_info) == (int) R_V810_LONGCALL)
+	    {
+	      /* Check code for -mlong-calls output. */
+	      if (laddr + 16 <= (bfd_vma) sec->size)
+		{
+		  insn[0] = bfd_get_16 (abfd, contents + laddr);
+		  insn[1] = bfd_get_16 (abfd, contents + laddr + 4);
+		  insn[2] = bfd_get_32 (abfd, contents + laddr + 8);
+		  insn[3] = bfd_get_16 (abfd, contents + laddr + 12);
+		  insn[4] = bfd_get_16 (abfd, contents + laddr + 14);
+
+		  if ((insn[0] & MOVHI_MASK) != MOVHI
+		       || MOVHI_R1 (insn[0]) != 0)
+		    no_match = 0;
+
+		  if (no_match < 0
+		      && ((insn[1] & MOVEA_MASK) != MOVEA
+			   || MOVHI_R2 (insn[0]) != MOVEA_R1 (insn[1])))
+		    no_match = 1;
+
+		  if (no_match < 0
+		      && (insn[2] & JAL_4_MASK) != JAL_4)
+		    no_match = 2;
+
+		  if (no_match < 0
+		      && ((insn[3] & ADD_I_MASK) != ADD_I
+			   || ADD_I5 (insn[3]) != 4))
+		    no_match = 3;
+
+		  if (no_match < 0
+		      && ((insn[4] & JMP_R_MASK) != JMP_R
+			   || MOVEA_R2 (insn[1]) != JMP_R1 (insn[4])))
+		    no_match = 4;
+		}
+	      else
+		{
+		  ((*_bfd_error_handler)
+		   ("%s: 0x%lx: warning: R_V810_LONGCALL points to unrecognized insns",
+		    bfd_get_filename (abfd), (unsigned long) irel->r_offset));
+
+		  continue;
+		}
+
+	      if (no_match >= 0)
+		{
+		  ((*_bfd_error_handler)
+		   ("%s: 0x%lx: warning: R_V810_LONGCALL points to unrecognized insn 0x%x",
+		    bfd_get_filename (abfd), (unsigned long) irel->r_offset+no_match, insn[no_match]));
+
+		  continue;
+		}
+
+	      /* Get the reloc for the address from which the register is
+	         being loaded.  This reloc will tell us which function is
+	         actually being called.  */
+	      for (hi_irelfn = internal_relocs; hi_irelfn < irelend; hi_irelfn ++)
+		if (hi_irelfn->r_offset == laddr + 2
+		    && ELF32_R_TYPE (hi_irelfn->r_info)
+		        == (int) R_V810_HI16_S)
+		  break;
+
+	      for (lo_irelfn = internal_relocs; lo_irelfn < irelend; lo_irelfn ++)
+		if (lo_irelfn->r_offset == laddr + 6
+		    && ELF32_R_TYPE (lo_irelfn->r_info)
+		        == (int) R_V810_LO16)
+		  break;
+
+	      for (irelcall = internal_relocs; irelcall < irelend; irelcall ++)
+		if (irelcall->r_offset == laddr + 8
+		    && ELF32_R_TYPE (irelcall->r_info)
+                        == (int) R_V810_26_PCREL)
+		  break;
+
+	      if (   hi_irelfn == irelend
+		  || lo_irelfn == irelend
+		  || irelcall  == irelend)
+		{
+		  ((*_bfd_error_handler)
+		   ("%s: 0x%lx: warning: R_V810_LONGCALL points to unrecognized reloc",
+		    bfd_get_filename (abfd), (unsigned long) irel->r_offset ));
+
+		  continue;
+		}
+
+	      if (ELF32_R_SYM (irelcall->r_info) < symtab_hdr->sh_info)
+		{
+		  Elf_Internal_Sym *  isym;
+
+		  /* A local symbol.  */
+		  isym = isymbuf + ELF32_R_SYM (irelcall->r_info);
+
+		  symval = isym->st_value;
+		}
+	      else
+		{
+		  unsigned long indx;
+		  struct elf_link_hash_entry * h;
+
+		  /* An external symbol.  */
+		  indx = ELF32_R_SYM (irelcall->r_info) - symtab_hdr->sh_info;
+		  h = elf_sym_hashes (abfd)[indx];
+		  BFD_ASSERT (h != NULL);
+
+		  if (   h->root.type != bfd_link_hash_defined
+		      && h->root.type != bfd_link_hash_defweak)
+		    /* This appears to be a reference to an undefined
+		       symbol.  Just ignore it--it will be caught by the
+		       regular reloc processing.  */
+		    continue;
+
+		  symval = h->root.u.def.value;
+		}
+
+	      if (symval + irelcall->r_addend != irelcall->r_offset + 4)
+		{
+		  ((*_bfd_error_handler)
+		   ("%s: 0x%lx: warning: R_V810_LONGCALL points to unrecognized reloc 0x%lx",
+		    bfd_get_filename (abfd), (unsigned long) irel->r_offset, irelcall->r_offset ));
+
+		  continue;
+		}
+
+	      /* Get the value of the symbol referred to by the reloc.  */
+	      if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
+		{
+		  Elf_Internal_Sym *isym;
+		  asection *sym_sec;
+
+		  /* A local symbol.  */
+		  isym = isymbuf + ELF32_R_SYM (hi_irelfn->r_info);
+
+		  if (isym->st_shndx == SHN_UNDEF)
+		    sym_sec = bfd_und_section_ptr;
+		  else if (isym->st_shndx == SHN_ABS)
+		    sym_sec = bfd_abs_section_ptr;
+		  else if (isym->st_shndx == SHN_COMMON)
+		    sym_sec = bfd_com_section_ptr;
+		  else
+		    sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
+		  symval = (isym->st_value
+			    + sym_sec->output_section->vma
+			    + sym_sec->output_offset);
+		}
+	      else
+		{
+		  unsigned long indx;
+		  struct elf_link_hash_entry *h;
+
+		  /* An external symbol.  */
+		  indx = ELF32_R_SYM (hi_irelfn->r_info) - symtab_hdr->sh_info;
+		  h = elf_sym_hashes (abfd)[indx];
+		  BFD_ASSERT (h != NULL);
+
+		  if (   h->root.type != bfd_link_hash_defined
+		      && h->root.type != bfd_link_hash_defweak)
+		    /* This appears to be a reference to an undefined
+		       symbol.  Just ignore it--it will be caught by the
+		       regular reloc processing.  */
+		    continue;
+
+		  symval = (h->root.u.def.value
+			    + h->root.u.def.section->output_section->vma
+			    + h->root.u.def.section->output_offset);
+		}
+
+	      addend = irel->r_addend;
+
+	      foff = (symval + addend
+		      - (irel->r_offset
+			 + sec->output_section->vma
+			 + sec->output_offset
+			 + 4));
+#ifdef DEBUG_RELAX
+	      fprintf (stderr, "relax longcall r_offset 0x%x ptr 0x%x symbol 0x%x addend 0x%x distance 0x%x\n",
+		       irel->r_offset,
+		       (irel->r_offset
+			+ sec->output_section->vma
+			+ sec->output_offset),
+		       symval, addend, foff);
+#endif
+
+	      if (foff < -0x1000000 || foff >= 0x1000000)
+		/* After all that work, we can't shorten this function call.  */
+		continue;
+
+	      /* For simplicity of coding, we are going to modify the section
+	         contents, the section relocs, and the BFD symbol table.  We
+	         must tell the rest of the code not to free up this
+	         information.  It would be possible to instead create a table
+	         of changes which have to be made, as is done in coff-mips.c;
+	         that would be more work, but would require less memory when
+	         the linker is run.  */
+	      elf_section_data (sec)->relocs = internal_relocs;
+	      elf_section_data (sec)->this_hdr.contents = contents;
+	      symtab_hdr->contents = (bfd_byte *) isymbuf;
+
+	      /* Replace the long call with a jal.  */
+	      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V810_26_PCREL);
+
+	      addend = 0;
+
+	      if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
+		/* If this needs to be changed because of future relaxing,
+		   it will be handled here like other internal IND12W
+		   relocs.  */
+		bfd_put_32 (abfd,
+			    0x0000ac00 | ((addend << 16) & 0xffff) | ((addend >> 16) & 0x3ff),
+			    contents + irel->r_offset);
+	      else
+		/* We can't fully resolve this yet, because the external
+		   symbol value may be changed by future relaxing.
+		   We let the final link phase handle it.  */
+		bfd_put_32 (abfd, 0x0000ac00, contents + irel->r_offset);
+
+	      hi_irelfn->r_info =
+		ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V810_NONE);
+	      lo_irelfn->r_info =
+		ELF32_R_INFO (ELF32_R_SYM (lo_irelfn->r_info), R_V810_NONE);
+	      irelcall->r_info =
+		ELF32_R_INFO (ELF32_R_SYM (irelcall->r_info), R_V810_NONE);
+
+	      if (! v810_elf_relax_delete_bytes (abfd, sec,
+						 irel->r_offset + 4, toaddr, 12))
+		goto error_return;
+
+	      align_pad_size += 12;
+	    }
+	  else if (ELF32_R_TYPE (irel->r_info) == (int) R_V810_LONGJUMP)
+	    {
+	      /* Check code for -mlong-jumps output.  */
+	      if (laddr + 10 <= (bfd_vma) sec->size)
+		{
+		  insn[0] = bfd_get_16 (abfd, contents + laddr);
+		  insn[1] = bfd_get_16 (abfd, contents + laddr + 4);
+		  insn[2] = bfd_get_16 (abfd, contents + laddr + 8);
+
+		  if ((insn[0] & MOVHI_MASK) != MOVHI
+		       || MOVHI_R1 (insn[0]) != 0)
+		    no_match = 0;
+
+		  if (no_match < 0
+		      && ((insn[1] & MOVEA_MASK) != MOVEA
+			   || MOVHI_R2 (insn[0]) != MOVEA_R1 (insn[1])))
+		    no_match = 1;
+
+		  if (no_match < 0
+		      && ((insn[2] & JMP_R_MASK) != JMP_R
+			   || MOVEA_R2 (insn[1]) != JMP_R1 (insn[2])))
+		    no_match = 4;
+		}
+	      else
+		{
+		  ((*_bfd_error_handler)
+		   ("%s: 0x%lx: warning: R_V810_LONGJUMP points to unrecognized insns",
+		    bfd_get_filename (abfd), (unsigned long) irel->r_offset));
+
+		  continue;
+		}
+
+	      if (no_match >= 0)
+		{
+		  ((*_bfd_error_handler)
+		   ("%s: 0x%lx: warning: R_V810_LONGJUMP points to unrecognized insn 0x%x",
+		    bfd_get_filename (abfd), (unsigned long) irel->r_offset+no_match, insn[no_match]));
+
+		  continue;
+		}
+
+	      /* Get the reloc for the address from which the register is
+	         being loaded.  This reloc will tell us which function is
+	         actually being called.  */
+	      for (hi_irelfn = internal_relocs; hi_irelfn < irelend; hi_irelfn ++)
+		if (hi_irelfn->r_offset == laddr + 2
+		    && ELF32_R_TYPE (hi_irelfn->r_info) == (int) R_V810_HI16_S)
+		  break;
+
+	      for (lo_irelfn = internal_relocs; lo_irelfn < irelend; lo_irelfn ++)
+		if (lo_irelfn->r_offset == laddr + 6
+		    && ELF32_R_TYPE (lo_irelfn->r_info) == (int) R_V810_LO16)
+		  break;
+
+	      if (   hi_irelfn == irelend
+		  || lo_irelfn == irelend)
+		{
+		  ((*_bfd_error_handler)
+		   ("%s: 0x%lx: warning: R_V810_LONGJUMP points to unrecognized reloc",
+		    bfd_get_filename (abfd), (unsigned long) irel->r_offset ));
+
+		  continue;
+		}
+
+	      /* Get the value of the symbol referred to by the reloc.  */
+	      if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
+		{
+		  Elf_Internal_Sym *  isym;
+		  asection *          sym_sec;
+
+		  /* A local symbol.  */
+		  isym = isymbuf + ELF32_R_SYM (hi_irelfn->r_info);
+
+		  if (isym->st_shndx == SHN_UNDEF)
+		    sym_sec = bfd_und_section_ptr;
+		  else if (isym->st_shndx == SHN_ABS)
+		    sym_sec = bfd_abs_section_ptr;
+		  else if (isym->st_shndx == SHN_COMMON)
+		    sym_sec = bfd_com_section_ptr;
+		  else
+		    sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
+		  symval = (isym->st_value
+			    + sym_sec->output_section->vma
+			    + sym_sec->output_offset);
+#ifdef DEBUG_RELAX
+		  {
+		    char * name = bfd_elf_string_from_elf_section
+		      (abfd, symtab_hdr->sh_link, isym->st_name);
+
+		    fprintf (stderr, "relax long jump local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n",
+			     sym_sec->name, name, isym->st_name,
+			     sym_sec->output_section->vma,
+			     sym_sec->output_offset,
+			     isym->st_value, irel->r_addend);
+		  }
+#endif
+		}
+	      else
+		{
+		  unsigned long indx;
+		  struct elf_link_hash_entry * h;
+
+		  /* An external symbol.  */
+		  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
+		  h = elf_sym_hashes (abfd)[indx];
+		  BFD_ASSERT (h != NULL);
+
+		  if (   h->root.type != bfd_link_hash_defined
+		      && h->root.type != bfd_link_hash_defweak)
+		    /* This appears to be a reference to an undefined
+		       symbol.  Just ignore it--it will be caught by the
+		       regular reloc processing.  */
+		    continue;
+
+		  symval = (h->root.u.def.value
+			    + h->root.u.def.section->output_section->vma
+			    + h->root.u.def.section->output_offset);
+#ifdef DEBUG_RELAX
+		  fprintf (stderr,
+			   "relax longjump defined: sec: %s, name: %s, value: %x + %x + %x addend %x\n",
+			   sec->name, h->root.root.string, h->root.u.def.value,
+			   sec->output_section->vma, sec->output_offset, irel->r_addend);
+#endif
+		}
+
+	      addend = irel->r_addend;
+
+	      foff = (symval + addend
+		      - (irel->r_offset
+			 + sec->output_section->vma
+			 + sec->output_offset
+			 + 4));
+#ifdef DEBUG_RELAX
+	      fprintf (stderr, "relax longjump r_offset 0x%x ptr 0x%x symbol 0x%x addend 0x%x distance 0x%x\n",
+		       irel->r_offset,
+		       (irel->r_offset
+			+ sec->output_section->vma
+			+ sec->output_offset),
+		       symval, addend, foff);
+#endif
+	      if (foff < -0x1000000 || foff >= 0x1000000)
+		/* After all that work, we can't shorten this function call.  */
+		continue;
+
+	      /* For simplicity of coding, we are going to modify the section
+	         contents, the section relocs, and the BFD symbol table.  We
+	         must tell the rest of the code not to free up this
+	         information.  It would be possible to instead create a table
+	         of changes which have to be made, as is done in coff-mips.c;
+	         that would be more work, but would require less memory when
+	         the linker is run.  */
+	      elf_section_data (sec)->relocs = internal_relocs;
+	      elf_section_data (sec)->this_hdr.contents = contents;
+	      symtab_hdr->contents = (bfd_byte *) isymbuf;
+
+	      if (foff < -0x100 || foff >= 0x100)
+		{
+		  /* Replace the long jump with a jr.  */
+
+		  irel->r_info =
+		    ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_V810_26_PCREL);
+
+		  irel->r_addend = addend;
+		  addend = 0;
+
+		  if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
+		    /* If this needs to be changed because of future relaxing,
+		       it will be handled here like other internal IND12W
+		       relocs.  */
+		    bfd_put_32 (abfd,
+				0x0000a800 | ((addend << 16) & 0xffff0000) | ((addend >> 16) & 0x3ff),
+				contents + irel->r_offset);
+		  else
+		    /* We can't fully resolve this yet, because the external
+		       symbol value may be changed by future relaxing.
+		       We let the final link phase handle it.  */
+		    bfd_put_32 (abfd, 0x0000a800, contents + irel->r_offset);
+
+		  hi_irelfn->r_info =
+			ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V810_NONE);
+		  lo_irelfn->r_info =
+			ELF32_R_INFO (ELF32_R_SYM (lo_irelfn->r_info), R_V810_NONE);
+		  if (!v810_elf_relax_delete_bytes (abfd, sec,
+						    irel->r_offset + 4, toaddr, 6))
+		    goto error_return;
+
+		  align_pad_size += 6;
+		}
+	      else
+		{
+		  /* Replace the long jump with a br.  */
+
+		  irel->r_info =
+			ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_V810_9_PCREL);
+
+		  irel->r_addend = addend;
+		  addend = 0;
+
+		  if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
+		    /* If this needs to be changed because of future relaxing,
+		       it will be handled here like other internal IND12W
+		       relocs.  */
+		    bfd_put_16 (abfd, 0x8a00 | (addend & 0x1ff),
+				contents + irel->r_offset);
+		  else
+		    /* We can't fully resolve this yet, because the external
+		       symbol value may be changed by future relaxing.
+		       We let the final link phase handle it.  */
+		    bfd_put_16 (abfd, 0x8a00, contents + irel->r_offset);
+
+		  hi_irelfn->r_info =
+			ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V810_NONE);
+		  lo_irelfn->r_info =
+			ELF32_R_INFO (ELF32_R_SYM (lo_irelfn->r_info), R_V810_NONE);
+		  if (!v810_elf_relax_delete_bytes (abfd, sec,
+						    irel->r_offset + 2, toaddr, 8))
+		    goto error_return;
+
+		  align_pad_size += 8;
+		}
+	    }
+	}
+
+      irelalign = NULL;
+      for (irel = internal_relocs; irel < irelend; irel++)
+	{
+	  if (ELF32_R_TYPE (irel->r_info) == (int) R_V810_ALIGN
+	      && irel->r_offset == toaddr)
+	    {
+	      irel->r_offset -= align_pad_size;
+
+	      if (irelalign == NULL || irelalign->r_addend > irel->r_addend)
+		irelalign = irel;
+	    }
+	}
+
+      addr = toaddr;
+    }
+
+  if (!irelalign)
+    {
+#ifdef DEBUG_RELAX
+      fprintf (stderr, "relax pad %d shorten %d -> %d\n",
+	       align_pad_size,
+	       sec->size,
+	       sec->size - align_pad_size);
+#endif
+      sec->size -= align_pad_size;
+    }
+
+ finish:
+  if (internal_relocs != NULL
+      && elf_section_data (sec)->relocs != internal_relocs)
+    free (internal_relocs);
+
+  if (contents != NULL
+      && elf_section_data (sec)->this_hdr.contents != (unsigned char *) contents)
+    free (contents);
+
+  if (isymbuf != NULL
+      && symtab_hdr->contents != (bfd_byte *) isymbuf)
+    free (isymbuf);
+
+  return result;
+
+ error_return:
+  result = FALSE;
+  goto finish;
+}
+
+static const struct bfd_elf_special_section v810_elf_special_sections[] =
+{
+  { STRING_COMMA_LEN (".rosdata"),        -2, SHT_PROGBITS,     (SHF_ALLOC
+								 + SHF_V810_GPREL) },
+  { STRING_COMMA_LEN (".rozdata"),        -2, SHT_PROGBITS,     (SHF_ALLOC
+								 + SHF_V810_R0REL) },
+  { STRING_COMMA_LEN (".sbss"),           -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
+								 + SHF_V810_GPREL) },
+  { STRING_COMMA_LEN (".scommon"),        -2, SHT_V810_SCOMMON, (SHF_ALLOC + SHF_WRITE
+								 + SHF_V810_GPREL) },
+  { STRING_COMMA_LEN (".sdata"),          -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
+								 + SHF_V810_GPREL) },
+  { STRING_COMMA_LEN (".zbss"),           -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
+								 + SHF_V810_R0REL) },
+  { STRING_COMMA_LEN (".zcommon"),        -2, SHT_V810_ZCOMMON, (SHF_ALLOC + SHF_WRITE
+								 + SHF_V810_R0REL) },
+  { STRING_COMMA_LEN (".zdata"),          -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
+								 + SHF_V810_R0REL) },
+  { NULL,                     0,           0, 0,                0 }
+};
+
+#define TARGET_LITTLE_SYM			bfd_elf32_v810_vec
+#define TARGET_LITTLE_NAME			"elf32-v810"
+#define ELF_ARCH				bfd_arch_v810
+#define ELF_MACHINE_CODE			EM_V810
+#define ELF_MAXPAGESIZE				0x1000
+
+#define elf_info_to_howto			v810_elf_info_to_howto_rela
+#define elf_info_to_howto_rel			v810_elf_info_to_howto_rel
+
+#define elf_backend_check_relocs		v810_elf_check_relocs
+#define elf_backend_relocate_section    	v810_elf_relocate_section
+#define elf_backend_object_p			v810_elf_object_p
+#define elf_backend_final_write_processing 	v810_elf_final_write_processing
+#define elf_backend_section_from_bfd_section 	v810_elf_section_from_bfd_section
+#define elf_backend_symbol_processing		v810_elf_symbol_processing
+#define elf_backend_add_symbol_hook		v810_elf_add_symbol_hook
+#define elf_backend_link_output_symbol_hook 	v810_elf_link_output_symbol_hook
+#define elf_backend_section_from_shdr		v810_elf_section_from_shdr
+#define elf_backend_fake_sections		v810_elf_fake_sections
+#define elf_backend_gc_mark_hook                v810_elf_gc_mark_hook
+#define elf_backend_special_sections		v810_elf_special_sections
+
+#define elf_backend_can_gc_sections 1
+#define elf_backend_rela_normal 1
+
+#define bfd_elf32_bfd_is_local_label_name	v810_elf_is_local_label_name
+#define bfd_elf32_bfd_reloc_type_lookup		v810_elf_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup	v810_elf_reloc_name_lookup
+#define bfd_elf32_bfd_merge_private_bfd_data 	v810_elf_merge_private_bfd_data
+#define bfd_elf32_bfd_set_private_flags		v810_elf_set_private_flags
+#define bfd_elf32_bfd_print_private_bfd_data	v810_elf_print_private_bfd_data
+#define bfd_elf32_bfd_relax_section		v810_elf_relax_section
+
+#define elf_symbol_leading_char			'_'
+
+#include "elf32-target.h"
diff -Nbaur binutils-2.23.1/bfd/libbfd.h binutils-2.23.1-v810/bfd/libbfd.h
--- binutils-2.23.1/bfd/libbfd.h	2012-09-04 13:53:42 +0100
+++ binutils-2.23.1-v810/bfd/libbfd.h	2013-03-10 21:25:38 +0000
@@ -1729,6 +1729,13 @@
   "BFD_RELOC_M32R_GOTPC_HI_ULO",
   "BFD_RELOC_M32R_GOTPC_HI_SLO",
   "BFD_RELOC_M32R_GOTPC_LO",
+  "BFD_RELOC_V810_9_PCREL",
+  "BFD_RELOC_V810_26_PCREL",
+  "BFD_RELOC_V810_SDA_16_16_OFFSET",
+  "BFD_RELOC_V810_ZDA_16_16_OFFSET",
+  "BFD_RELOC_V810_LONGCALL",
+  "BFD_RELOC_V810_LONGJUMP",
+  "BFD_RELOC_V810_ALIGN",
   "BFD_RELOC_V850_9_PCREL",
   "BFD_RELOC_V850_22_PCREL",
   "BFD_RELOC_V850_SDA_16_16_OFFSET",
diff -Nbaur binutils-2.23.1/bfd/reloc.c binutils-2.23.1-v810/bfd/reloc.c
--- binutils-2.23.1/bfd/reloc.c	2012-09-04 13:53:42 +0100
+++ binutils-2.23.1-v810/bfd/reloc.c	2013-03-10 21:30:21 +0000
@@ -3815,6 +3815,35 @@
 ENUMDOC
   For PIC.
 
+ENUM
+  BFD_RELOC_V810_9_PCREL
+ENUMDOC
+  This is a 9-bit reloc
+ENUM
+  BFD_RELOC_V810_26_PCREL
+ENUMDOC
+  This is a 26-bit reloc
+
+ENUM
+  BFD_RELOC_V810_SDA_16_16_OFFSET
+ENUMDOC
+  This is a 16 bit offset from the short data area pointer.
+ENUM
+  BFD_RELOC_V810_ZDA_16_16_OFFSET
+ENUMDOC
+  This is a 16 bit offset from the zero data area pointer.
+ENUM
+  BFD_RELOC_V810_LONGCALL
+ENUMDOC
+  Used for relaxing indirect function calls.
+ENUM
+  BFD_RELOC_V810_LONGJUMP
+ENUMDOC
+  Used for relaxing indirect jumps.
+ENUM
+  BFD_RELOC_V810_ALIGN
+ENUMDOC
+  Used to maintain alignment whilst relaxing.
 
 ENUM
   BFD_RELOC_V850_9_PCREL
diff -Nbaur binutils-2.23.1/bfd/targets.c binutils-2.23.1-v810/bfd/targets.c
--- binutils-2.23.1/bfd/targets.c	2012-09-04 13:53:42 +0100
+++ binutils-2.23.1-v810/bfd/targets.c	2013-03-09 17:59:20 +0000
@@ -719,6 +719,7 @@
 extern const bfd_target bfd_elf32_tradbigmips_freebsd_vec;
 extern const bfd_target bfd_elf32_tradlittlemips_freebsd_vec;
 extern const bfd_target bfd_elf32_us_cris_vec;
+extern const bfd_target bfd_elf32_v810_vec;
 extern const bfd_target bfd_elf32_v850_vec;
 extern const bfd_target bfd_elf32_vax_vec;
 extern const bfd_target bfd_elf32_xc16x_vec;
@@ -1095,6 +1096,7 @@
 	&bfd_elf32_tradbigmips_freebsd_vec,
 	&bfd_elf32_tradlittlemips_freebsd_vec,
 	&bfd_elf32_us_cris_vec,
+	&bfd_elf32_v810_vec,
 	&bfd_elf32_v850_vec,
 	&bfd_elf32_vax_vec,
 	&bfd_elf32_xc16x_vec,
diff -Nbaur binutils-2.23.1/binutils/readelf.c binutils-2.23.1-v810/binutils/readelf.c
--- binutils-2.23.1/binutils/readelf.c	2012-11-05 16:27:35 +0000
+++ binutils-2.23.1-v810/binutils/readelf.c	2013-03-09 17:59:21 +0000
@@ -146,6 +146,7 @@
 #include "elf/tic6x.h"
 #include "elf/tilegx.h"
 #include "elf/tilepro.h"
+#include "elf/v810.h"
 #include "elf/v850.h"
 #include "elf/vax.h"
 #include "elf/x86-64.h"
@@ -616,6 +617,7 @@
     case EM_TI_C6000:
     case EM_TILEGX:
     case EM_TILEPRO:
+    case EM_V810:
     case EM_V850:
     case EM_CYGNUS_V850:
     case EM_VAX:
@@ -1040,6 +1042,10 @@
 	  rtype = elf_spu_reloc_type (type);
 	  break;
 
+	case EM_V810:
+	  rtype = v810_reloc_type (type);
+	  break;
+
 	case EM_V850:
 	case EM_CYGNUS_V850:
 	  rtype = v850_reloc_type (type);
@@ -1891,6 +1897,7 @@
     case EM_D30V:		return "d30v";
     case EM_CYGNUS_M32R:
     case EM_M32R:		return "Renesas M32R (formerly Mitsubishi M32r)";
+    case EM_V810:		return "NEC V810";
     case EM_CYGNUS_V850:
     case EM_V850:		return "Renesas V850";
     case EM_CYGNUS_MN10300:
@@ -2363,6 +2370,21 @@
 	    strcat (buf, _(", relocatable-lib"));
 	  break;
 
+	case EM_V810:
+	  switch (e_flags & EF_V810_ARCH)
+	    {
+	    case E_V830_ARCH:
+	      strcat (buf, ", v830");
+	      break;
+	    case E_V810_ARCH:
+	      strcat (buf, ", v810");
+	      break;
+	    default:
+	      strcat (buf, _(", unknown v810 architecture variant"));
+	      break;
+	    }
+	  break;
+
 	case EM_V850:
 	case EM_CYGNUS_V850:
 	  switch (e_flags & EF_V850_ARCH)
@@ -9939,6 +9961,8 @@
       return reloc_type == 2; /* R_TILEGX_32.  */
     case EM_TILEPRO:
       return reloc_type == 1; /* R_TILEPRO_32.  */
+    case EM_V810:
+      return reloc_type == 6; /* R_V810_32.  */
     case EM_CYGNUS_V850:
     case EM_V850:
       return reloc_type == 6; /* R_V850_ABS32.  */
diff -Nbaur binutils-2.23.1/binutils/testsuite/binutils-all/objdump.exp binutils-2.23.1-v810/binutils/testsuite/binutils-all/objdump.exp
--- binutils-2.23.1/binutils/testsuite/binutils-all/objdump.exp	2012-09-04 13:53:44 +0100
+++ binutils-2.23.1-v810/binutils/testsuite/binutils-all/objdump.exp	2013-03-09 17:59:21 +0000
@@ -42,7 +42,7 @@
 lappend cpus_expected mips mn10200 mn10300 ms1 msp ns32k pj powerpc pyramid
 lappend cpus_expected romp rs6000 s390 sh sparc
 lappend cpus_expected tahoe tic54x tic80 tilegx tms320c30 tms320c4x tms320c54x
-lappend cpus_expected v850 vax we32k x86-64 xscale xtensa z8k z8001 z8002
+lappend cpus_expected v810 v850 vax we32k x86-64 xscale xtensa z8k z8001 z8002
 
 # Make sure the target CPU shows up in the list.
 lappend cpus_expected ${target_cpu}
diff -Nbaur binutils-2.23.1/config.sub binutils-2.23.1-v810/config.sub
--- binutils-2.23.1/config.sub	2012-04-25 16:53:25 +0100
+++ binutils-2.23.1-v810/config.sub	2013-03-09 17:59:21 +0000
@@ -313,7 +313,7 @@
 	| spu \
 	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
 	| ubicom32 \
-	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
+	| v810 | v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
 	| we32k \
 	| x86 | xc16x | xstormy16 | xtensa \
 	| z8k | z80)
@@ -430,7 +430,7 @@
 	| tile*-* \
 	| tron-* \
 	| ubicom32-* \
-	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
+	| v810-* | v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
 	| vax-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xc16x-* | xps100-* \
diff -Nbaur binutils-2.23.1/configure binutils-2.23.1-v810/configure
--- binutils-2.23.1/configure	2012-06-28 12:50:52 +0100
+++ binutils-2.23.1-v810/configure	2013-03-09 17:59:21 +0000
@@ -3615,7 +3615,7 @@
     noconfigdirs="$noconfigdirs sim"
     ;;
   v810-*-*)
-    noconfigdirs="$noconfigdirs bfd binutils gas gdb ld opcodes target-libgloss"
+    noconfigdirs="$noconfigdirs target-libgloss"
     ;;
   vax-*-*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
diff -Nbaur binutils-2.23.1/gas/Makefile.am binutils-2.23.1-v810/gas/Makefile.am
--- binutils-2.23.1/gas/Makefile.am	2012-09-04 13:53:45 +0100
+++ binutils-2.23.1-v810/gas/Makefile.am	2013-03-09 17:59:21 +0000
@@ -167,6 +167,7 @@
 	config/tc-tilegx.c \
 	config/tc-tilepro.c \
 	config/tc-vax.c \
+	config/tc-v810.c \
 	config/tc-v850.c \
 	config/tc-xstormy16.c \
 	config/tc-xc16x.c \
@@ -236,6 +237,7 @@
 	config/tc-tilegx.h \
 	config/tc-tilepro.h \
 	config/tc-vax.h \
+	config/tc-v810.h \
 	config/tc-v850.h \
 	config/tc-xstormy16.h \
 	config/tc-xc16x.h \
diff -Nbaur binutils-2.23.1/gas/Makefile.in binutils-2.23.1-v810/gas/Makefile.in
--- binutils-2.23.1/gas/Makefile.in	2012-09-04 13:53:45 +0100
+++ binutils-2.23.1-v810/gas/Makefile.in	2013-03-09 17:59:21 +0000
@@ -435,6 +435,7 @@
 	config/tc-tilegx.c \
 	config/tc-tilepro.c \
 	config/tc-vax.c \
+	config/tc-v810.c \
 	config/tc-v850.c \
 	config/tc-xstormy16.c \
 	config/tc-xc16x.c \
@@ -504,6 +505,7 @@
 	config/tc-tilegx.h \
 	config/tc-tilepro.h \
 	config/tc-vax.h \
+	config/tc-v810.h \
 	config/tc-v850.h \
 	config/tc-xstormy16.h \
 	config/tc-xc16x.h \
@@ -854,6 +856,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-tic6x.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-tilegx.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-tilepro.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-v810.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-v850.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-vax.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-xc16x.Po@am__quote@
@@ -1727,6 +1730,20 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-vax.obj `if test -f 'config/tc-vax.c'; then $(CYGPATH_W) 'config/tc-vax.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-vax.c'; fi`
 
+tc-v810.o: config/tc-v810.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-v810.o -MD -MP -MF $(DEPDIR)/tc-v810.Tpo -c -o tc-v810.o `test -f 'config/tc-v810.c' || echo '$(srcdir)/'`config/tc-v810.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-v810.Tpo $(DEPDIR)/tc-v810.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-v810.c' object='tc-v810.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-v810.o `test -f 'config/tc-v810.c' || echo '$(srcdir)/'`config/tc-v810.c
+
+tc-v810.obj: config/tc-v810.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-v810.obj -MD -MP -MF $(DEPDIR)/tc-v810.Tpo -c -o tc-v810.obj `if test -f 'config/tc-v810.c'; then $(CYGPATH_W) 'config/tc-v810.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-v810.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-v810.Tpo $(DEPDIR)/tc-v810.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-v810.c' object='tc-v810.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-v810.obj `if test -f 'config/tc-v810.c'; then $(CYGPATH_W) 'config/tc-v810.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-v810.c'; fi`
+
 tc-v850.o: config/tc-v850.c
 @am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-v850.o -MD -MP -MF $(DEPDIR)/tc-v850.Tpo -c -o tc-v850.o `test -f 'config/tc-v850.c' || echo '$(srcdir)/'`config/tc-v850.c
 @am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-v850.Tpo $(DEPDIR)/tc-v850.Po
diff -Nbaur binutils-2.23.1/gas/app.c binutils-2.23.1-v810/gas/app.c
--- binutils-2.23.1/gas/app.c	2012-06-07 13:47:23 +0100
+++ binutils-2.23.1-v810/gas/app.c	2013-03-09 17:59:21 +0000
@@ -72,7 +72,7 @@
 #define	LEX_IS_COLON			9
 #define	LEX_IS_NEWLINE			10
 #define	LEX_IS_ONECHAR_QUOTE		11
-#ifdef TC_V850
+#if (defined (TC_V850) || defined (TC_V810))
 #define LEX_IS_DOUBLEDASH_1ST		12
 #endif
 #ifdef TC_M32R
@@ -187,7 +187,7 @@
     }
 #endif
 
-#ifdef TC_V850
+#if (defined (TC_V850) || defined (TC_V810))
   lex['-'] = LEX_IS_DOUBLEDASH_1ST;
 #endif
 #ifdef DOUBLEBAR_PARALLEL
@@ -377,7 +377,7 @@
 	 11: After seeing a symbol character in state 0 (eg a label definition)
 	 -1: output string in out_string and go to the state in old_state
 	 -2: flush text until a '*' '/' is seen, then go to state old_state
-#ifdef TC_V850
+#if (defined (TC_V850) || defined (TC_V810))
 	 12: After seeing a dash, looking for a second dash as a start
 	     of comment.
 #endif
@@ -1134,7 +1134,7 @@
 	  PUT (ch);
 	  break;
 
-#ifdef TC_V850
+#if (defined (TC_V850) || defined (TC_V810))
 	case LEX_IS_DOUBLEDASH_1ST:
 	  ch2 = GET ();
 	  if (ch2 != '-')
diff -Nbaur binutils-2.23.1/gas/config/tc-v810.c binutils-2.23.1-v810/gas/config/tc-v810.c
--- binutils-2.23.1/gas/config/tc-v810.c	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/config/tc-v810.c	2013-03-15 19:07:03 +0000
@@ -0,0 +1,2100 @@
+/* tc-v810.c -- Assembler code for the NEC V810
+   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
+   2006, 2007, 2009, 2010, 2011  Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to
+   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "as.h"
+#include "safe-ctype.h"
+#include "subsegs.h"
+#include "opcode/v810.h"
+#include "dwarf2dbg.h"
+
+/* Sign-extend a 16-bit number.  */
+#define SEXT16(x)	((((x) & 0xffff) ^ (~0x7fff)) + 0x8000)
+
+/* Temporarily holds the reloc in a cons expression.  */
+static bfd_reloc_code_real_type hold_cons_reloc = BFD_RELOC_UNUSED;
+
+/* Set to TRUE if we want to be pedantic about signed overflows.  */
+static bfd_boolean warn_signed_overflows   = FALSE;
+static bfd_boolean warn_unsigned_overflows = FALSE;
+
+/* Indicates the target BFD machine number.  */
+static int machine = -1;
+
+/* Indicates the target processor(s) for the assemble.  */
+static int processor_mask = 0;
+
+/* Structure to hold information about predefined registers.  */
+struct reg_name
+{
+  const char *name;
+  int value;
+  unsigned int processors;
+};
+
+/* Generic assembler global variables which must be defined by all
+   targets.  */
+
+/* Characters which always start a comment.  */
+const char comment_chars[] = "#";
+
+/* Characters which start a comment at the beginning of a line.  */
+const char line_comment_chars[] = ";#";
+
+/* Characters which may be used to separate multiple commands on a
+   single line.  */
+const char line_separator_chars[] = ";";
+
+/* Characters which are used to indicate an exponent in a floating
+   point number.  */
+const char EXP_CHARS[] = "eE";
+
+/* Characters which mean that a number is a floating point constant,
+   as in 0d1.0.  */
+const char FLT_CHARS[] = "dD";
+
+const relax_typeS md_relax_table[] =
+{
+  /* Conditional branches.  */
+#define SUBYPTE_COND_9_26	0
+  {0xfe,	 -0x100,        2, SUBYPTE_COND_9_26 + 1},
+  {0x1fffffe + 2, -0x2000000 + 2, 6, 0},
+  /* Unconditional branches.  */
+#define SUBYPTE_UNCOND_9_26	2
+  {0xfe,     -0x100,    2, SUBYPTE_UNCOND_9_26 + 1},
+  {0x1fffffe, -0x2000000, 4, 0},
+};
+
+static int v810_relax = 0;
+
+/* Fixups.  */
+#define MAX_INSN_FIXUPS   5
+
+struct v810_fixup
+{
+  expressionS exp;
+  int opindex;
+  bfd_reloc_code_real_type reloc;
+};
+
+struct v810_fixup fixups[MAX_INSN_FIXUPS];
+static int fc;
+
+struct v810_seg_entry
+{
+  segT s;
+  const char *name;
+  flagword flags;
+};
+
+struct v810_seg_entry v810_seg_table[] =
+{
+  { NULL, ".sdata",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
+    | SEC_SMALL_DATA },
+  { NULL, ".zdata",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS },
+  { NULL, ".sbss",
+    SEC_ALLOC | SEC_SMALL_DATA },
+  { NULL, ".zbss",
+    SEC_ALLOC},
+  { NULL, ".rosdata",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_READONLY | SEC_DATA
+    | SEC_HAS_CONTENTS | SEC_SMALL_DATA },
+  { NULL, ".rozdata",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_READONLY | SEC_DATA
+    | SEC_HAS_CONTENTS },
+  { NULL, ".scommon",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
+    | SEC_SMALL_DATA | SEC_IS_COMMON },
+  { NULL, ".zcommon",
+    SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA | SEC_HAS_CONTENTS
+    | SEC_IS_COMMON },
+  { NULL, ".bss",
+    SEC_ALLOC }
+};
+
+#define SDATA_SECTION		0
+#define ZDATA_SECTION		1
+#define SBSS_SECTION		2
+#define ZBSS_SECTION		3
+#define ROSDATA_SECTION		4
+#define ROZDATA_SECTION		5
+#define SCOMMON_SECTION		6
+#define ZCOMMON_SECTION		7
+#define BSS_SECTION		8
+
+static void
+do_v810_seg (int i, subsegT sub)
+{
+  struct v810_seg_entry *seg = v810_seg_table + i;
+
+  obj_elf_section_change_hook ();
+
+  if (seg->s != NULL)
+    subseg_set (seg->s, sub);
+  else
+    {
+      seg->s = subseg_new (seg->name, sub);
+      bfd_set_section_flags (stdoutput, seg->s, seg->flags);
+      if ((seg->flags & SEC_LOAD) == 0)
+	seg_info (seg->s)->bss = 1;
+    }
+}
+
+static void
+v810_seg (int i)
+{
+  subsegT sub = get_absolute_expression ();
+
+  do_v810_seg (i, sub);
+  demand_empty_rest_of_line ();
+}
+
+static void
+v810_offset (int ignore ATTRIBUTE_UNUSED)
+{
+  char *pfrag;
+  int temp = get_absolute_expression ();
+
+  pfrag = frag_var (rs_org, 1, 1, (relax_substateT)0, (symbolS *)0,
+		    (offsetT) temp, (char *) 0);
+  *pfrag = 0;
+
+  demand_empty_rest_of_line ();
+}
+
+/* Copied from obj_elf_common() in gas/config/obj-elf.c.  */
+
+static void
+v810_comm (int area)
+{
+  char *name;
+  char c;
+  char *p;
+  int temp;
+  unsigned int size;
+  symbolS *symbolP;
+  int have_align;
+
+  name = input_line_pointer;
+  c = get_symbol_end ();
+
+  /* Just after name is now '\0'.  */
+  p = input_line_pointer;
+  *p = c;
+
+  SKIP_WHITESPACE ();
+
+  if (*input_line_pointer != ',')
+    {
+      as_bad (_("Expected comma after symbol-name"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  /* Skip ','.  */
+  input_line_pointer++;
+
+  if ((temp = get_absolute_expression ()) < 0)
+    {
+      /* xgettext:c-format  */
+      as_bad (_(".COMMon length (%d.) < 0! Ignored."), temp);
+      ignore_rest_of_line ();
+      return;
+    }
+
+  size = temp;
+  *p = 0;
+  symbolP = symbol_find_or_make (name);
+  *p = c;
+
+  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
+    {
+      as_bad (_("Ignoring attempt to re-define symbol"));
+      ignore_rest_of_line ();
+      return;
+    }
+
+  if (S_GET_VALUE (symbolP) != 0)
+    {
+      if (S_GET_VALUE (symbolP) != size)
+	/* xgettext:c-format  */
+	as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %d."),
+		 S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
+    }
+
+  know (symbol_get_frag (symbolP) == &zero_address_frag);
+
+  if (*input_line_pointer != ',')
+    have_align = 0;
+  else
+    {
+      have_align = 1;
+      input_line_pointer++;
+      SKIP_WHITESPACE ();
+    }
+
+  if (! have_align || *input_line_pointer != '"')
+    {
+      if (! have_align)
+	temp = 0;
+      else
+	{
+	  temp = get_absolute_expression ();
+
+	  if (temp < 0)
+	    {
+	      temp = 0;
+	      as_warn (_("Common alignment negative; 0 assumed"));
+	    }
+	}
+
+      if (symbol_get_obj (symbolP)->local)
+	{
+	  segT old_sec;
+	  int old_subsec;
+	  char *pfrag;
+	  int align;
+	  flagword applicable;
+
+	  old_sec = now_seg;
+	  old_subsec = now_subseg;
+
+	  applicable = bfd_applicable_section_flags (stdoutput);
+
+	  applicable &= SEC_ALLOC;
+
+	  switch (area)
+	    {
+	    case SCOMMON_SECTION:
+	      do_v810_seg (SBSS_SECTION, 0);
+	      break;
+
+	    case ZCOMMON_SECTION:
+	      do_v810_seg (ZBSS_SECTION, 0);
+	      break;
+
+	    }
+
+	  if (temp)
+	    {
+	      /* Convert to a power of 2 alignment.  */
+	      for (align = 0; (temp & 1) == 0; temp >>= 1, ++align)
+		;
+
+	      if (temp != 1)
+		{
+		  as_bad (_("Common alignment not a power of 2"));
+		  ignore_rest_of_line ();
+		  return;
+		}
+	    }
+	  else
+	    align = 0;
+
+	  record_alignment (now_seg, align);
+
+	  if (align)
+	    frag_align (align, 0, 0);
+
+	  switch (area)
+	    {
+	    case SCOMMON_SECTION:
+	      if (S_GET_SEGMENT (symbolP) == v810_seg_table[SBSS_SECTION].s)
+		symbol_get_frag (symbolP)->fr_symbol = 0;
+	      break;
+
+	    case ZCOMMON_SECTION:
+	      if (S_GET_SEGMENT (symbolP) == v810_seg_table[ZBSS_SECTION].s)
+		symbol_get_frag (symbolP)->fr_symbol = 0;
+	      break;
+
+	    default:
+	      abort ();
+	    }
+
+	  symbol_set_frag (symbolP, frag_now);
+	  pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+			    (offsetT) size, (char *) 0);
+	  *pfrag = 0;
+	  S_SET_SIZE (symbolP, size);
+
+	  switch (area)
+	    {
+	    case SCOMMON_SECTION:
+	      S_SET_SEGMENT (symbolP, v810_seg_table[SBSS_SECTION].s);
+	      break;
+
+	    case ZCOMMON_SECTION:
+	      S_SET_SEGMENT (symbolP, v810_seg_table[ZBSS_SECTION].s);
+	      break;
+
+	    default:
+	      abort ();
+	    }
+
+	  S_CLEAR_EXTERNAL (symbolP);
+	  obj_elf_section_change_hook ();
+	  subseg_set (old_sec, old_subsec);
+	}
+      else
+	{
+	  segT   old_sec;
+	  int    old_subsec;
+
+	allocate_common:
+	  old_sec = now_seg;
+	  old_subsec = now_subseg;
+
+	  S_SET_VALUE (symbolP, (valueT) size);
+	  S_SET_ALIGN (symbolP, temp);
+	  S_SET_EXTERNAL (symbolP);
+
+	  switch (area)
+	    {
+	    case SCOMMON_SECTION:
+	    case ZCOMMON_SECTION:
+	      do_v810_seg (area, 0);
+	      S_SET_SEGMENT (symbolP, v810_seg_table[area].s);
+	      break;
+
+	    default:
+	      abort ();
+	    }
+
+	  obj_elf_section_change_hook ();
+	  subseg_set (old_sec, old_subsec);
+	}
+    }
+  else
+    {
+      input_line_pointer++;
+
+      /* @@ Some use the dot, some don't.  Can we get some consistency??  */
+      if (*input_line_pointer == '.')
+	input_line_pointer++;
+
+      /* @@ Some say data, some say bss.  */
+      if (strncmp (input_line_pointer, "bss\"", 4)
+	  && strncmp (input_line_pointer, "data\"", 5))
+	{
+	  while (*--input_line_pointer != '"')
+	    ;
+	  input_line_pointer--;
+	  goto bad_common_segment;
+	}
+
+      while (*input_line_pointer++ != '"')
+	;
+
+      goto allocate_common;
+    }
+
+  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;
+
+  demand_empty_rest_of_line ();
+  return;
+
+  {
+  bad_common_segment:
+    p = input_line_pointer;
+    while (*p && *p != '\n')
+      p++;
+    c = *p;
+    *p = '\0';
+    as_bad (_("bad .common segment %s"), input_line_pointer + 1);
+    *p = c;
+    input_line_pointer = p;
+    ignore_rest_of_line ();
+    return;
+  }
+}
+
+static void
+set_machine (int number)
+{
+  machine = number;
+  bfd_set_arch_mach (stdoutput, TARGET_ARCH, machine);
+
+  switch (machine)
+    {
+    case 0:                SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V810);    break;
+    case bfd_mach_v830:    SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V830);    break;
+    }
+}
+
+static void
+v810_longcode (int type)
+{
+  expressionS ex;
+
+  if (! v810_relax)
+    {
+      if (type == 1)
+	as_warn (_(".longcall pseudo-op seen when not relaxing"));
+      else
+	as_warn (_(".longjump pseudo-op seen when not relaxing"));
+    }
+
+  expression (&ex);
+
+  if (ex.X_op != O_symbol || ex.X_add_number != 0)
+    {
+      as_bad (_("bad .longcall format"));
+      ignore_rest_of_line ();
+
+      return;
+    }
+
+  if (type == 1)
+    fix_new_exp (frag_now, frag_now_fix (), 4, & ex, 1,
+		 BFD_RELOC_V810_LONGCALL);
+  else
+    fix_new_exp (frag_now, frag_now_fix (), 4, & ex, 1,
+		 BFD_RELOC_V810_LONGJUMP);
+
+  demand_empty_rest_of_line ();
+}
+
+/* The target specific pseudo-ops which we support.  */
+const pseudo_typeS md_pseudo_table[] =
+{
+  { "sdata",		v810_seg,		SDATA_SECTION		},
+  { "zdata",		v810_seg,		ZDATA_SECTION		},
+  { "sbss",		v810_seg,		SBSS_SECTION		},
+  { "zbss",		v810_seg,		ZBSS_SECTION		},
+  { "rosdata",		v810_seg,		ROSDATA_SECTION 	},
+  { "rozdata",		v810_seg,		ROZDATA_SECTION 	},
+  { "bss",		v810_seg,		BSS_SECTION		},
+  { "offset",		v810_offset,		0			},
+  { "word",		cons,			4			},
+  { "zcomm",		v810_comm,		ZCOMMON_SECTION 	},
+  { "scomm",		v810_comm,		SCOMMON_SECTION 	},
+  { "v810",		set_machine,		0			},
+  { "v830",		set_machine,		bfd_mach_v830		},
+  { "longcall",		v810_longcode,		1			},
+  { "longjump",		v810_longcode,		2			},
+  { NULL,		NULL,			0			}
+};
+
+/* Opcode hash table.  */
+static struct hash_control *v810_hash;
+
+/* This table is sorted.  Suitable for searching by a binary search.  */
+static const struct reg_name pre_defined_registers[] =
+{
+  { "gp",   4, PROCESSOR_ALL },		/* gp - global ptr.  */
+  { "hp",   2, PROCESSOR_ALL },		/* hp - handler stack ptr.  */
+  { "lp",  31, PROCESSOR_ALL },		/* lp - link ptr.  */
+  { "r0",   0, PROCESSOR_ALL },
+  { "r1",   1, PROCESSOR_ALL },
+  { "r10", 10, PROCESSOR_ALL },
+  { "r11", 11, PROCESSOR_ALL },
+  { "r12", 12, PROCESSOR_ALL },
+  { "r13", 13, PROCESSOR_ALL },
+  { "r14", 14, PROCESSOR_ALL },
+  { "r15", 15, PROCESSOR_ALL },
+  { "r16", 16, PROCESSOR_ALL },
+  { "r17", 17, PROCESSOR_ALL },
+  { "r18", 18, PROCESSOR_ALL },
+  { "r19", 19, PROCESSOR_ALL },
+  { "r2",   2, PROCESSOR_ALL },
+  { "r20", 20, PROCESSOR_ALL },
+  { "r21", 21, PROCESSOR_ALL },
+  { "r22", 22, PROCESSOR_ALL },
+  { "r23", 23, PROCESSOR_ALL },
+  { "r24", 24, PROCESSOR_ALL },
+  { "r25", 25, PROCESSOR_ALL },
+  { "r26", 26, PROCESSOR_ALL },
+  { "r27", 27, PROCESSOR_ALL },
+  { "r28", 28, PROCESSOR_ALL },
+  { "r29", 29, PROCESSOR_ALL },
+  { "r3",   3, PROCESSOR_ALL },
+  { "r30", 30, PROCESSOR_ALL },
+  { "r31", 31, PROCESSOR_ALL },
+  { "r4",   4, PROCESSOR_ALL },
+  { "r5",   5, PROCESSOR_ALL },
+  { "r6",   6, PROCESSOR_ALL },
+  { "r7",   7, PROCESSOR_ALL },
+  { "r8",   8, PROCESSOR_ALL },
+  { "r9",   9, PROCESSOR_ALL },
+  { "sp",   3, PROCESSOR_ALL },		/* sp - stack ptr.  */
+  { "tp",   5, PROCESSOR_ALL },		/* tp - text ptr.  */
+  { "zero", 0, PROCESSOR_ALL },
+};
+
+#define REG_NAME_CNT						\
+  (sizeof (pre_defined_registers) / sizeof (struct reg_name))
+
+static const struct reg_name system_registers[] =
+{
+  { "adtre", 25, PROCESSOR_ALL },
+  { "chcw",  24, PROCESSOR_ALL },
+  { "ecr",    4, PROCESSOR_ALL },
+  { "eipc",   0, PROCESSOR_ALL },
+  { "eipsw",  1, PROCESSOR_ALL },
+  { "fepc",   2, PROCESSOR_ALL },
+  { "fepsw",  3, PROCESSOR_ALL },
+  { "pir",    6, PROCESSOR_ALL },
+  { "psw",    5, PROCESSOR_ALL },
+  { "sr0",    0, PROCESSOR_ALL },
+  { "sr1",    1, PROCESSOR_ALL },
+  { "sr10",  10, PROCESSOR_ALL },
+  { "sr11",  11, PROCESSOR_ALL },
+  { "sr12",  12, PROCESSOR_ALL },
+  { "sr13",  13, PROCESSOR_ALL },
+  { "sr14",  14, PROCESSOR_ALL },
+  { "sr15",  15, PROCESSOR_ALL },
+  { "sr16",  16, PROCESSOR_ALL },
+  { "sr17",  17, PROCESSOR_ALL },
+  { "sr18",  18, PROCESSOR_ALL },
+  { "sr19",  19, PROCESSOR_ALL },
+  { "sr2",    2, PROCESSOR_ALL },
+  { "sr20",  20, PROCESSOR_ALL },
+  { "sr21",  21, PROCESSOR_ALL },
+  { "sr22",  22, PROCESSOR_ALL },
+  { "sr23",  23, PROCESSOR_ALL },
+  { "sr24",  24, PROCESSOR_ALL },
+  { "sr25",  25, PROCESSOR_ALL },
+  { "sr26",  26, PROCESSOR_ALL },
+  { "sr27",  27, PROCESSOR_ALL },
+  { "sr28",  28, PROCESSOR_ALL },
+  { "sr29",  29, PROCESSOR_ALL },
+  { "sr3",    3, PROCESSOR_ALL },
+  { "sr30",  30, PROCESSOR_ALL },
+  { "sr31",  31, PROCESSOR_ALL },
+  { "sr4",    4, PROCESSOR_ALL },
+  { "sr5",    5, PROCESSOR_ALL },
+  { "sr6",    6, PROCESSOR_ALL },
+  { "sr7",    7, PROCESSOR_ALL },
+  { "sr8",    8, PROCESSOR_ALL },
+  { "sr9",    9, PROCESSOR_ALL },
+  { "tkcw",   7, PROCESSOR_ALL },
+};
+
+#define SYSREG_NAME_CNT						\
+  (sizeof (system_registers) / sizeof (struct reg_name))
+
+static const struct reg_name cc_names[] =
+{
+  { "c",  0x1, PROCESSOR_ALL },
+  { "e",  0x2, PROCESSOR_ALL },
+  { "ge", 0xe, PROCESSOR_ALL },
+  { "gt", 0xf, PROCESSOR_ALL },
+  { "h",  0xb, PROCESSOR_ALL },
+  { "l",  0x1, PROCESSOR_ALL },
+  { "le", 0x7, PROCESSOR_ALL },
+  { "lt", 0x6, PROCESSOR_ALL },
+  { "n",  0x4, PROCESSOR_ALL },
+  { "nc", 0x9, PROCESSOR_ALL },
+  { "ne", 0xa, PROCESSOR_ALL },
+  { "nh", 0x3, PROCESSOR_ALL },
+  { "nl", 0x9, PROCESSOR_ALL },
+  { "ns", 0xc, PROCESSOR_ALL },
+  { "nv", 0x8, PROCESSOR_ALL },
+  { "nz", 0xa, PROCESSOR_ALL },
+  { "p",  0xc, PROCESSOR_ALL },
+  { "s",  0x4, PROCESSOR_ALL },
+  { "f",  0xd, PROCESSOR_ALL },
+  { "t",  0x5, PROCESSOR_ALL },
+  { "v",  0x0, PROCESSOR_ALL },
+  { "z",  0x2, PROCESSOR_ALL },
+};
+
+#define CC_NAME_CNT					\
+  (sizeof (cc_names) / sizeof (struct reg_name))
+
+/* Do a binary search of the given register table to see if NAME is a
+   valid regiter name.  Return the register number from the array on
+   success, or -1 on failure.  */
+
+static int
+reg_name_search (const struct reg_name *regs,
+		 int regcount,
+		 const char *name,
+		 bfd_boolean accept_numbers)
+{
+  int middle, low, high;
+  int cmp;
+  symbolS *symbolP;
+
+  /* If the register name is a symbol, then evaluate it.  */
+  if ((symbolP = symbol_find (name)) != NULL)
+    {
+      /* If the symbol is an alias for another name then use that.
+	 If the symbol is an alias for a number, then return the number.  */
+      if (symbol_equated_p (symbolP))
+	name
+	  = S_GET_NAME (symbol_get_value_expression (symbolP)->X_add_symbol);
+      else if (accept_numbers)
+	{
+	  int reg = S_GET_VALUE (symbolP);
+	  return reg;
+	}
+
+      /* Otherwise drop through and try parsing name normally.  */
+    }
+
+  low = 0;
+  high = regcount - 1;
+
+  do
+    {
+      middle = (low + high) / 2;
+      cmp = strcasecmp (name, regs[middle].name);
+      if (cmp < 0)
+	high = middle - 1;
+      else if (cmp > 0)
+	low = middle + 1;
+      else
+	return ((regs[middle].processors & processor_mask)
+		? regs[middle].value
+		: -1);
+    }
+  while (low <= high);
+  return -1;
+}
+
+/* Summary of register_name().
+
+   in: Input_line_pointer points to 1st char of operand.
+
+   out: An expressionS.
+  	The operand may have been a register: in this case, X_op == O_register,
+  	X_add_number is set to the register number, and truth is returned.
+  	Input_line_pointer->(next non-blank) char after operand, or is in
+  	its original state.  */
+
+static bfd_boolean
+register_name (expressionS *expressionP)
+{
+  int reg_number;
+  char *name;
+  char *start;
+  char c;
+
+  /* Find the spelling of the operand.  */
+  start = name = input_line_pointer;
+
+  c = get_symbol_end ();
+
+  reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT,
+				name, FALSE);
+
+  /* Put back the delimiting char.  */
+  *input_line_pointer = c;
+
+  expressionP->X_add_symbol = NULL;
+  expressionP->X_op_symbol  = NULL;
+
+  /* Look to see if it's in the register table.  */
+  if (reg_number >= 0)
+    {
+      expressionP->X_op		= O_register;
+      expressionP->X_add_number = reg_number;
+
+      return TRUE;
+    }
+
+  /* Reset the line as if we had not done anything.  */
+  input_line_pointer = start;
+
+  expressionP->X_op = O_illegal;
+
+  return FALSE;
+}
+
+/* Summary of system_register_name().
+
+   in:  INPUT_LINE_POINTER points to 1st char of operand.
+	EXPRESSIONP points to an expression structure to be filled in.
+	ACCEPT_NUMBERS is true iff numerical register names may be used.
+
+   out: An expressionS structure in expressionP.
+  	The operand may have been a register: in this case, X_op == O_register,
+  	X_add_number is set to the register number, and truth is returned.
+  	Input_line_pointer->(next non-blank) char after operand, or is in
+  	its original state.  */
+
+static bfd_boolean
+system_register_name (expressionS *expressionP,
+		      bfd_boolean accept_numbers)
+{
+  int reg_number;
+  char *name;
+  char *start;
+  char c;
+
+  /* Find the spelling of the operand.  */
+  start = name = input_line_pointer;
+
+  c = get_symbol_end ();
+  reg_number = reg_name_search (system_registers, SYSREG_NAME_CNT, name,
+				accept_numbers);
+
+  /* Put back the delimiting char.  */
+  *input_line_pointer = c;
+
+  if (reg_number < 0
+      && accept_numbers)
+    {
+      /* Reset input_line pointer.  */
+      input_line_pointer = start;
+
+      if (ISDIGIT (*input_line_pointer))
+	{
+	  reg_number = strtol (input_line_pointer, &input_line_pointer, 0);
+	}
+    }
+
+  expressionP->X_add_symbol = NULL;
+  expressionP->X_op_symbol  = NULL;
+
+  /* Look to see if it's in the register table.  */
+  if (reg_number >= 0)
+    {
+      expressionP->X_op		= O_register;
+      expressionP->X_add_number = reg_number;
+
+      return TRUE;
+    }
+
+  /* Reset the line as if we had not done anything.  */
+  input_line_pointer = start;
+
+  expressionP->X_op = O_illegal;
+
+  return FALSE;
+}
+
+/* Summary of cc_name().
+
+   in: INPUT_LINE_POINTER points to 1st char of operand.
+
+   out: An expressionS.
+  	The operand may have been a register: in this case, X_op == O_register,
+  	X_add_number is set to the register number, and truth is returned.
+  	Input_line_pointer->(next non-blank) char after operand, or is in
+  	its original state.  */
+
+static bfd_boolean
+cc_name (expressionS *expressionP,
+	 bfd_boolean accept_numbers)
+{
+  int reg_number;
+  char *name;
+  char *start;
+  char c;
+
+  /* Find the spelling of the operand.  */
+  start = name = input_line_pointer;
+
+  c = get_symbol_end ();
+  reg_number = reg_name_search (cc_names, CC_NAME_CNT, name, accept_numbers);
+
+  /* Put back the delimiting char.  */
+  *input_line_pointer = c;
+
+  if (reg_number < 0
+      && accept_numbers)
+    {
+      /* Reset input_line pointer.  */
+      input_line_pointer = start;
+
+      if (ISDIGIT (*input_line_pointer))
+	{
+	  reg_number = strtol (input_line_pointer, &input_line_pointer, 0);
+	}
+    }
+
+  expressionP->X_add_symbol = NULL;
+  expressionP->X_op_symbol  = NULL;
+
+  /* Look to see if it's in the register table.  */
+  if (reg_number >= 0)
+    {
+      expressionP->X_op		= O_constant;
+      expressionP->X_add_number = reg_number;
+
+      return TRUE;
+    }
+
+  /* Reset the line as if we had not done anything.  */
+  input_line_pointer = start;
+
+  expressionP->X_op = O_illegal;
+  expressionP->X_add_number = 0;
+
+  return FALSE;
+}
+
+const char *md_shortopts = "m:";
+
+struct option md_longopts[] =
+{
+  {NULL, no_argument, NULL, 0}
+};
+
+size_t md_longopts_size = sizeof (md_longopts);
+
+void
+md_show_usage (FILE *stream)
+{
+  fprintf (stream, _(" V810 options:\n"));
+  fprintf (stream, _("  -mwarn-signed-overflow    Warn if signed immediate values overflow\n"));
+  fprintf (stream, _("  -mwarn-unsigned-overflow  Warn if unsigned immediate values overflow\n"));
+  fprintf (stream, _("  -mv810                    The code is targeted at the v810\n"));
+  fprintf (stream, _("  -mv830                    The code is targeted at the v830\n"));
+  fprintf (stream, _("  -mrelax                   Enable relaxation\n"));
+}
+
+int
+md_parse_option (int c, char *arg)
+{
+  if (strcmp (arg, "warn-signed-overflow") == 0)
+    warn_signed_overflows = TRUE;
+
+  else if (strcmp (arg, "warn-unsigned-overflow") == 0)
+    warn_unsigned_overflows = TRUE;
+
+  else if (strcmp (arg, "v810") == 0)
+    {
+      machine = 0;
+      SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V810);
+    }
+  else if (strcmp (arg, "v830") == 0)
+    {
+      machine = bfd_mach_v830;
+      SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V830);
+    }
+  else if (strcmp (arg, "relax") == 0)
+    v810_relax = 1;
+  else
+    return 0;
+
+  return 1;
+}
+
+symbolS *
+md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+char *
+md_atof (int type, char *litp, int *sizep)
+{
+  return ieee_md_atof (type, litp, sizep, FALSE);
+}
+
+/* Very gross.  */
+
+void
+md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
+		 asection *sec,
+		 fragS *fragP)
+{
+  union u
+  {
+    bfd_reloc_code_real_type fx_r_type;
+    char * fr_opcode;
+  }
+  opcode_converter;
+  subseg_change (sec, 0);
+
+  opcode_converter.fr_opcode = fragP->fr_opcode;
+
+  subseg_change (sec, 0);
+
+  /* In range conditional or unconditional branch.  */
+  if (fragP->fr_subtype == SUBYPTE_COND_9_26
+      || fragP->fr_subtype == SUBYPTE_UNCOND_9_26)
+
+    {
+      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
+	       fragP->fr_offset, 1,
+	       BFD_RELOC_UNUSED + opcode_converter.fx_r_type);
+      fragP->fr_fix += 2;
+    }
+  /* Out of range conditional branch.  Emit a branch around a jump.  */
+  else if (fragP->fr_subtype == SUBYPTE_COND_9_26 + 1)
+    {
+      unsigned char *buffer =
+	(unsigned char *) (fragP->fr_fix + fragP->fr_literal);
+
+      /* Reverse the condition of the first branch.  */
+      buffer[0] ^= 0x10;
+      /* Mask off all the displacement bits.  */
+      buffer[0] &= 0x00;
+      buffer[1] &= 0xfe;
+      /* Now set the displacement bits so that we branch
+	 around the unconditional branch.  */
+      buffer[0] |= 0x06;
+
+      /* Now create the unconditional branch + fixup to the final
+	 target.  */
+      md_number_to_chars ((char *) buffer + 2, 0x0000a800, 4);
+      fix_new (fragP, fragP->fr_fix + 2, 4, fragP->fr_symbol,
+	       fragP->fr_offset, 1, BFD_RELOC_V810_26_PCREL);
+      fragP->fr_fix += 6;
+    }
+  /* Out of range unconditional branch.  Emit a jump.  */
+  else if (fragP->fr_subtype == SUBYPTE_UNCOND_9_26 + 1)
+    {
+      md_number_to_chars (fragP->fr_fix + fragP->fr_literal, 0x0000a800, 4);
+      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
+	       fragP->fr_offset, 1, BFD_RELOC_V810_26_PCREL);
+      fragP->fr_fix += 4;
+    }
+  else
+    abort ();
+}
+
+valueT
+md_section_align (asection *seg, valueT addr)
+{
+  int align = bfd_get_section_alignment (stdoutput, seg);
+  return ((addr + (1 << align) - 1) & (-1 << align));
+}
+
+void
+md_begin (void)
+{
+  char *prev_name = "";
+  const struct v810_opcode *op;
+
+  if (strncmp (TARGET_CPU, "v830", 4) == 0)
+    {
+      if (machine == -1)
+        machine = bfd_mach_v830;
+
+      if (!processor_mask)
+        SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V830);
+    }
+  else if (strncmp (TARGET_CPU, "v810", 4) == 0)
+    {
+      if (machine == -1)
+	machine = 0;
+
+      if (!processor_mask)
+	SET_PROCESSOR_MASK (processor_mask, PROCESSOR_V810);
+    }
+  else
+    /* xgettext:c-format  */
+    as_bad (_("Unable to determine default target processor from string: %s"),
+	    TARGET_CPU);
+
+  v810_hash = hash_new ();
+
+  /* Insert unique names into hash table.  The V810 instruction set
+     has many identical opcode names that have different opcodes based
+     on the operands.  This hash table then provides a quick index to
+     the first opcode with a particular name in the opcode table.  */
+  op = v810_opcodes;
+  while (op->name)
+    {
+      if (strcmp (prev_name, op->name))
+	{
+	  prev_name = (char *) op->name;
+	  hash_insert (v810_hash, op->name, (char *) op);
+	}
+      op++;
+    }
+
+  v810_seg_table[BSS_SECTION].s = bss_section;
+  bfd_set_arch_mach (stdoutput, TARGET_ARCH, machine);
+}
+
+
+static bfd_reloc_code_real_type
+handle_hi016 (const struct v810_operand *operand, const char **errmsg)
+{
+  if (operand == NULL)
+    return BFD_RELOC_HI16;
+
+  if (operand->default_reloc == BFD_RELOC_HI16)
+    return BFD_RELOC_HI16;
+
+  if (operand->default_reloc == BFD_RELOC_HI16_S)
+    return BFD_RELOC_HI16;
+
+  if (operand->default_reloc == BFD_RELOC_16)
+    return BFD_RELOC_HI16;
+
+  *errmsg = _("hi0() relocation used on an instruction which does "
+	      "not support it");
+  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
+}
+
+static bfd_reloc_code_real_type
+handle_hi16 (const struct v810_operand *operand, const char **errmsg)
+{
+  if (operand == NULL)
+    return BFD_RELOC_HI16_S;
+
+  if (operand->default_reloc == BFD_RELOC_HI16_S)
+    return BFD_RELOC_HI16_S;
+
+  if (operand->default_reloc == BFD_RELOC_HI16)
+    return BFD_RELOC_HI16_S;
+
+  if (operand->default_reloc == BFD_RELOC_16)
+    return BFD_RELOC_HI16_S;
+
+  *errmsg = _("hi() relocation used on an instruction which does "
+	      "not support it");
+  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
+}
+
+static bfd_reloc_code_real_type
+handle_lo16 (const struct v810_operand *operand, const char **errmsg)
+{
+  if (operand == NULL)
+    return BFD_RELOC_LO16;
+
+  if (operand->default_reloc == BFD_RELOC_LO16)
+    return BFD_RELOC_LO16;
+
+  if (operand->default_reloc == BFD_RELOC_16)
+    return BFD_RELOC_LO16;
+
+  *errmsg = _("lo() relocation used on an instruction which does "
+	      "not support it");
+  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
+}
+
+static bfd_reloc_code_real_type
+handle_sdaoff (const struct v810_operand *operand, const char **errmsg)
+{
+  if (operand == NULL)
+    return BFD_RELOC_V810_SDA_16_16_OFFSET;
+
+  if (operand->default_reloc == BFD_RELOC_16)
+    return BFD_RELOC_V810_SDA_16_16_OFFSET;
+
+  *errmsg = _("sdaoff() relocation used on an instruction which does not support it");
+  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
+}
+
+static bfd_reloc_code_real_type
+handle_zdaoff (const struct v810_operand *operand, const char **errmsg)
+{
+  if (operand == NULL)
+    return BFD_RELOC_V810_ZDA_16_16_OFFSET;
+
+  if (operand->default_reloc == BFD_RELOC_16)
+    return BFD_RELOC_V810_ZDA_16_16_OFFSET;
+
+  *errmsg = _("zdaoff() relocation used on an instruction which does not support it");
+  return BFD_RELOC_64;  /* Used to indicate an error condition.  */
+}
+
+/* Warning: The code in this function relies upon the definitions
+   in the v810_operands[] array (defined in opcodes/v810-opc.c)
+   matching the hard coded values contained herein.  */
+
+static bfd_reloc_code_real_type
+v810_reloc_prefix (const struct v810_operand *operand, const char **errmsg)
+{
+  bfd_boolean paren_skipped = FALSE;
+
+  /* Skip leading opening parenthesis.  */
+  if (*input_line_pointer == '(')
+    {
+      ++input_line_pointer;
+      paren_skipped = TRUE;
+    }
+
+#define CHECK_(name, reloc) 						\
+  if (strncmp (input_line_pointer, name "(", strlen (name) + 1) == 0)	\
+    {									\
+      input_line_pointer += strlen (name);				\
+      return reloc;							\
+    }
+
+  CHECK_ ("hi0",    handle_hi016(operand, errmsg)  );
+  CHECK_ ("hi",	    handle_hi16(operand, errmsg)   );
+  CHECK_ ("lo",	    handle_lo16 (operand, errmsg)  );
+  CHECK_ ("sdaoff", handle_sdaoff (operand, errmsg));
+  CHECK_ ("zdaoff", handle_zdaoff (operand, errmsg));
+
+  /* Restore skipped parenthesis.  */
+  if (paren_skipped)
+    --input_line_pointer;
+
+  return BFD_RELOC_UNUSED;
+}
+
+/* Insert an operand value into an instruction.  */
+
+static unsigned long
+v810_insert_operand (unsigned long insn,
+		     const struct v810_operand *operand,
+		     offsetT val,
+		     const char **errmsg)
+{
+  if (operand->insert)
+    {
+      const char *message = NULL;
+
+      insn = operand->insert (insn, val, &message);
+      if (message != NULL)
+	{
+	  if ((operand->flags & V810_OPERAND_SIGNED)
+	      && ! warn_signed_overflows
+              && v810_msg_is_out_of_range (message))
+	    {
+	      /* Skip warning...  */
+	    }
+	  else if ((operand->flags & V810_OPERAND_SIGNED) == 0
+		   && ! warn_unsigned_overflows
+                  && v810_msg_is_out_of_range (message))
+	    {
+	      /* Skip warning...  */
+	    }
+	  else
+	    {
+             if (errmsg != NULL)
+               *errmsg = message;
+	    }
+	}
+    }
+  else if (operand->bits == -1)
+    {
+      abort ();
+    }
+  else
+    {
+      if (operand->bits < 32)
+	{
+	  long min, max;
+
+	  if ((operand->flags & V810_OPERAND_SIGNED) != 0)
+	    {
+	      if (! warn_signed_overflows)
+		max = (1 << operand->bits) - 1;
+	      else
+		max = (1 << (operand->bits - 1)) - 1;
+
+	      min = -(1 << (operand->bits - 1));
+	    }
+	  else
+	    {
+	      max = (1 << operand->bits) - 1;
+
+	      if (! warn_unsigned_overflows)
+		min = -(1 << (operand->bits - 1));
+	      else
+		min = 0;
+	    }
+
+	  /* Some people write constants with the sign extension done by
+	     hand but only up to 32 bits.  This shouldn't really be valid,
+	     but, to permit this code to assemble on a 64-bit host, we
+	     sign extend the 32-bit value to 64 bits if so doing makes the
+	     value valid.  */
+	  if (val > max
+	      && (offsetT) (val - 0x80000000 - 0x80000000) >= min
+	      && (offsetT) (val - 0x80000000 - 0x80000000) <= max)
+	    val = val - 0x80000000 - 0x80000000;
+
+	  /* Similarly, people write expressions like ~(1<<15), and expect
+	     this to be OK for a 32-bit unsigned value.  */
+	  else if (val < min
+		   && (offsetT) (val + 0x80000000 + 0x80000000) >= min
+		   && (offsetT) (val + 0x80000000 + 0x80000000) <= max)
+	    val = val + 0x80000000 + 0x80000000;
+
+	  else if (val < (offsetT) min || val > (offsetT) max)
+	    {
+	      char buf [128];
+
+	      /* Restore min and mix to expected values for decimal ranges.  */
+	      if ((operand->flags & V810_OPERAND_SIGNED)
+		  && ! warn_signed_overflows)
+		max = (1 << (operand->bits - 1)) - 1;
+
+	      if (! (operand->flags & V810_OPERAND_SIGNED)
+		  && ! warn_unsigned_overflows)
+		min = 0;
+
+	      sprintf (buf, _("operand out of range (%d is not between %d and %d)"),
+		       (int) val, (int) min, (int) max);
+	      *errmsg = buf;
+	    }
+
+	  insn |= (((long) val & ((1 << operand->bits) - 1)) << operand->shift);
+	}
+      else
+	{
+	  insn |= (((long) val) << operand->shift);
+	}
+    }
+
+  return insn;
+}
+
+static char copy_of_instruction[128];
+
+void
+md_assemble (char *str)
+{
+  char *s;
+  char *start_of_operands;
+  struct v810_opcode *opcode;
+  struct v810_opcode *next_opcode;
+  const unsigned char *opindex_ptr;
+  int next_opindex;
+  int relaxable = 0;
+  unsigned long insn;
+  unsigned long insn_size;
+  char *f;
+  int i;
+  int match;
+  bfd_boolean extra_data_after_insn = FALSE;
+  unsigned extra_data_len = 0;
+  unsigned long extra_data = 0;
+  char *saved_input_line_pointer;
+  char most_match_errmsg[1024];
+  int most_match_count = -1;
+
+  strncpy (copy_of_instruction, str, sizeof (copy_of_instruction) - 1);
+  most_match_errmsg[0] = 0;
+
+  /* Get the opcode.  */
+  for (s = str; *s != '\0' && ! ISSPACE (*s); s++)
+    continue;
+
+  if (*s != '\0')
+    *s++ = '\0';
+
+  /* Find the first opcode with the proper name.  */
+  opcode = (struct v810_opcode *) hash_find (v810_hash, str);
+  if (opcode == NULL)
+    {
+      /* xgettext:c-format  */
+      as_bad (_("Unrecognized opcode: `%s'"), str);
+      ignore_rest_of_line ();
+      return;
+    }
+
+  str = s;
+  while (ISSPACE (*str))
+    ++str;
+
+  start_of_operands = str;
+
+  saved_input_line_pointer = input_line_pointer;
+
+  for (;;)
+    {
+      const char *errmsg = NULL;
+      const char *warningmsg = NULL;
+
+      match = 0;
+      opindex_ptr = opcode->operands;
+
+      if ((opcode->processors & processor_mask & PROCESSOR_MASK) == 0
+	  || (((opcode->processors & ~PROCESSOR_MASK) != 0)
+	      && ((opcode->processors & processor_mask & ~PROCESSOR_MASK) == 0)))
+	{
+	  errmsg = _("Target processor does not support this instruction.");
+	  goto error;
+	}
+
+      relaxable = 0;
+      fc = 0;
+      next_opindex = 0;
+      insn = opcode->opcode;
+      extra_data_len = 0;
+      extra_data_after_insn = FALSE;
+
+      input_line_pointer = str = start_of_operands;
+
+      for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++)
+	{
+	  const struct v810_operand *operand;
+	  char *hold;
+	  expressionS ex;
+	  bfd_reloc_code_real_type reloc;
+
+	  if (next_opindex == 0)
+	    operand = &v810_operands[*opindex_ptr];
+	  else
+	    {
+	      operand = &v810_operands[next_opindex];
+	      next_opindex = 0;
+	    }
+
+	  errmsg = NULL;
+
+	  while (*str == ' ')
+	    ++str;
+
+	  if (*str == ',' || *str == '[' || *str == ']')
+	    ++str;
+
+	  while (*str == ' ')
+	    ++str;
+
+	  if (operand->flags & V810_OPERAND_RELAX)
+	    relaxable = 1;
+
+	  /* Gather the operand.  */
+	  hold = input_line_pointer;
+	  input_line_pointer = str;
+
+	  /* lo(), hi(), hi0(), etc...  */
+	  if ((reloc = v810_reloc_prefix (operand, &errmsg)) != BFD_RELOC_UNUSED)
+	    {
+	      /* This is a fake reloc, used to indicate an error condition.  */
+	      if (reloc == BFD_RELOC_64)
+		{
+		  /* match = 1;  */
+		  goto error;
+		}
+
+	      expression (&ex);
+
+	      if (ex.X_op == O_constant)
+		{
+		  switch (reloc)
+		    {
+		    case BFD_RELOC_V810_ZDA_16_16_OFFSET:
+		      /* Fall through.  */
+
+		    case BFD_RELOC_LO16:
+		      {
+			/* Truncate, then sign extend the value.  */
+			ex.X_add_number = SEXT16 (ex.X_add_number);
+			break;
+		      }
+
+		    case BFD_RELOC_HI16:
+		      {
+			/* Truncate, then sign extend the value.  */
+			ex.X_add_number = SEXT16 (ex.X_add_number >> 16);
+			break;
+		      }
+
+		    case BFD_RELOC_HI16_S:
+		      {
+			/* Truncate, then sign extend the value.  */
+			int temp = (ex.X_add_number >> 16) & 0xffff;
+
+			temp += (ex.X_add_number >> 15) & 1;
+
+			ex.X_add_number = SEXT16 (temp);
+			break;
+		      }
+
+		    case BFD_RELOC_32:
+		      if ((operand->flags & 0) == 0)
+			{
+			  errmsg = _("immediate operand is too large");
+			  goto error;
+			}
+
+		      break;
+
+		    default:
+		      fprintf (stderr, "reloc: %d\n", reloc);
+		      as_bad (_("AAARG -> unhandled constant reloc"));
+		      break;
+		    }
+
+		  if (fc > MAX_INSN_FIXUPS)
+		    as_fatal (_("too many fixups"));
+
+		  fixups[fc].exp     = ex;
+		  fixups[fc].opindex = *opindex_ptr;
+		  fixups[fc].reloc   = reloc;
+		  fc++;
+		}
+	      else	/* ex.X_op != O_constant.  */
+		{
+		  if ((reloc == BFD_RELOC_32)
+		      && operand->bits < 32)
+		    {
+		      errmsg = _("immediate operand is too large");
+		      goto error;
+		    }
+		  else if ((reloc == BFD_RELOC_HI16
+			    || reloc == BFD_RELOC_HI16_S)
+			   && operand->bits < 16)
+		    {
+		      errmsg = _("immediate operand is too large");
+		      goto error;
+		    }
+
+		  if (fc > MAX_INSN_FIXUPS)
+		    as_fatal (_("too many fixups"));
+
+		  fixups[fc].exp     = ex;
+		  fixups[fc].opindex = *opindex_ptr;
+		  fixups[fc].reloc   = reloc;
+		  fc++;
+		}
+	    }
+	  else
+	    {
+	      errmsg = NULL;
+
+	      if ((operand->flags & V810_OPERAND_REG) != 0)
+		{
+		  if (!register_name (&ex))
+		    {
+		      errmsg = _("invalid register name");
+		    }
+		}
+	      else if ((operand->flags & V810_OPERAND_SRG) != 0)
+		{
+		  if (!system_register_name (&ex, TRUE))
+		    {
+		      errmsg = _("invalid system register name");
+		    }
+		}
+	      else if ((operand->flags & V810_OPERAND_CC) != 0)
+		{
+		  if (!cc_name (&ex, TRUE))
+		    {
+		      errmsg = _("invalid condition code name");
+		    }
+		}
+	      else if ((register_name (&ex)
+			&& (operand->flags & V810_OPERAND_REG) == 0))
+		{
+		  char c;
+		  int exists = 0;
+
+		  /* It is possible that an alias has been defined that
+		     matches a register name.  For example the code may
+		     include a ".set ZERO, 0" directive, which matches
+		     the register name "zero".  Attempt to reparse the
+		     field as an expression, and only complain if we
+		     cannot generate a constant.  */
+
+		  input_line_pointer = str;
+
+		  c = get_symbol_end ();
+
+		  if (symbol_find (str) != NULL)
+		    exists = 1;
+
+		  *input_line_pointer = c;
+		  input_line_pointer = str;
+
+		  expression (&ex);
+
+		  if (ex.X_op != O_constant)
+		    {
+		      /* If this register is actually occurring too early on
+			 the parsing of the instruction, (because another
+			 field is missing) then report this.  */
+		      if (opindex_ptr[1] != 0
+			  && (v810_operands[opindex_ptr[1]].flags
+			       & V810_OPERAND_REG))
+			errmsg = _("syntax error: value is missing before the register name");
+		      else
+			errmsg = _("syntax error: register not expected");
+
+		      /* If we created a symbol in the process of this
+			 test then delete it now, so that it will not
+			 be output with the real symbols...  */
+		      if (exists == 0
+			  && ex.X_op == O_symbol)
+			symbol_remove (ex.X_add_symbol,
+				       &symbol_rootP, &symbol_lastP);
+		    }
+		}
+	      else if (system_register_name (&ex, FALSE)
+		       && (operand->flags & V810_OPERAND_SRG) == 0)
+		{
+		  errmsg = _("syntax error: system register not expected");
+		}
+	      else if (cc_name (&ex, FALSE)
+		       && (operand->flags & V810_OPERAND_CC) == 0)
+		{
+		  errmsg = _("syntax error: condition code not expected");
+		}
+	      else
+		{
+		  expression (&ex);
+		  /* Special case:
+		     If we are assembling a MOV/JARL/JR instruction and the immediate
+		     value does not fit into the bits available then create a
+		     fake error so that the next MOV/JARL/JR instruction will be
+		     selected.  This one has a 32 bit immediate field.  */
+
+		  if ((strcmp (opcode->name, "mov") == 0
+		       || strcmp (opcode->name, "jal") == 0
+		       || strcmp (opcode->name, "jr") == 0)
+		      && ex.X_op == O_constant
+		      && (ex.X_add_number < (-(1 << (operand->bits - 1)))
+			  || ex.X_add_number > ((1 << (operand->bits - 1)) - 1)))
+		    {
+		      errmsg = _("immediate operand is too large");
+		    }
+		}
+
+	      if (errmsg)
+		goto error;
+
+	      switch (ex.X_op)
+		{
+		case O_illegal:
+		  errmsg = _("illegal operand");
+		  goto error;
+		case O_absent:
+		  errmsg = _("missing operand");
+		  goto error;
+		case O_register:
+		  if ((operand->flags
+		       & (V810_OPERAND_REG | V810_OPERAND_SRG)) == 0)
+		    {
+		      errmsg = _("invalid operand");
+		      goto error;
+		    }
+
+		  insn = v810_insert_operand (insn, operand,
+					      ex.X_add_number,
+					      &warningmsg);
+
+		  break;
+
+		case O_constant:
+		  insn = v810_insert_operand (insn, operand, ex.X_add_number,
+					      &warningmsg);
+		  break;
+
+		default:
+		  /* We need to generate a fixup for this expression.  */
+		  if (fc >= MAX_INSN_FIXUPS)
+		    as_fatal (_("too many fixups"));
+
+		  fixups[fc].exp     = ex;
+		  fixups[fc].opindex = *opindex_ptr;
+		  fixups[fc].reloc   = BFD_RELOC_UNUSED;
+		  ++fc;
+		  break;
+		}
+	    }
+
+	  str = input_line_pointer;
+	  input_line_pointer = hold;
+
+	  while (*str == ' ' || *str == ',' || *str == '[' || *str == ']'
+		 || *str == ')')
+	    ++str;
+	}
+
+      while (ISSPACE (*str))
+	++str;
+
+      if (*str == '\0')
+	match = 1;
+
+    error:
+      if (match == 0)
+	{
+	  if ((opindex_ptr - opcode->operands) >= most_match_count)
+	    {
+	      most_match_count = opindex_ptr - opcode->operands;
+	      if (errmsg != NULL)
+		strncpy (most_match_errmsg, errmsg, sizeof (most_match_errmsg)-1);
+	    }
+
+	  next_opcode = opcode + 1;
+	  if (next_opcode->name != NULL
+	      && strcmp (next_opcode->name, opcode->name) == 0)
+	    {
+	      opcode = next_opcode;
+
+	      /* Skip versions that are not supported by the target
+		 processor.  */
+	      if ((opcode->processors & processor_mask) == 0)
+		goto error;
+
+	      continue;
+	    }
+
+	  if (most_match_errmsg[0] == 0)
+	    /* xgettext:c-format.  */
+	    as_bad (_("junk at end of line: `%s'"), str);
+	  else
+	    as_bad ("%s: %s", copy_of_instruction, most_match_errmsg);
+
+	  if (*input_line_pointer == ']')
+	    ++input_line_pointer;
+
+	  ignore_rest_of_line ();
+	  input_line_pointer = saved_input_line_pointer;
+	  return;
+	}
+
+      if (warningmsg != NULL)
+	as_warn ("%s", warningmsg);
+      break;
+    }
+
+  input_line_pointer = str;
+
+  /* Tie dwarf2 debug info to the address at the start of the insn.
+     We can't do this after the insn has been output as the current
+     frag may have been closed off.  eg. by frag_var.  */
+  dwarf2_emit_insn (0);
+
+  /* Write out the instruction.  */
+
+  if (relaxable && fc > 0)
+    {
+      insn_size = 2;
+      fc = 0;
+
+      if (strcmp (opcode->name, "br") == 0)
+	{
+	  f = frag_var (rs_machine_dependent, 4, 2, SUBYPTE_UNCOND_9_26,
+			fixups[0].exp.X_add_symbol,
+			fixups[0].exp.X_add_number,
+			(char *)(size_t) fixups[0].opindex);
+	  md_number_to_chars (f, insn, insn_size);
+	  md_number_to_chars (f + 2, 0, 2);
+	}
+      else /* b<cond>, j<cond>.  */
+	{
+	  f = frag_var (rs_machine_dependent, 6, 4, SUBYPTE_COND_9_26,
+			fixups[0].exp.X_add_symbol,
+			fixups[0].exp.X_add_number,
+			(char *)(size_t) fixups[0].opindex);
+	  md_number_to_chars (f, insn, insn_size);
+	  md_number_to_chars (f + 2, 0, 4);
+	}
+    }
+  else
+    {
+      /* Four byte insns have an opcode with the two high bits on.  */
+      if ((insn & 0xfc00) >= 0xa000)
+	insn_size = 4;
+      else
+	insn_size = 2;
+
+      f = frag_more (insn_size);
+      md_number_to_chars (f, insn, insn_size);
+
+      if (extra_data_after_insn)
+	{
+	  f = frag_more (extra_data_len);
+	  md_number_to_chars (f, extra_data, extra_data_len);
+
+	  extra_data_after_insn = FALSE;
+	}
+    }
+
+  /* Create any fixups.  At this point we do not use a
+     bfd_reloc_code_real_type, but instead just use the
+     BFD_RELOC_UNUSED plus the operand index.  This lets us easily
+     handle fixups for any operand type, although that is admittedly
+     not a very exciting feature.  We pick a BFD reloc type in
+     md_apply_fix.  */
+  for (i = 0; i < fc; i++)
+    {
+      const struct v810_operand *operand;
+      bfd_reloc_code_real_type reloc;
+
+      operand = &v810_operands[fixups[i].opindex];
+
+      reloc = fixups[i].reloc;
+
+      if (reloc != BFD_RELOC_UNUSED)
+	{
+	  reloc_howto_type *reloc_howto =
+	    bfd_reloc_type_lookup (stdoutput, reloc);
+	  int size;
+	  int address;
+	  fixS *fixP;
+
+	  if (!reloc_howto)
+	    abort ();
+
+	  size = bfd_get_reloc_size (reloc_howto);
+
+	  /* XXX This will abort on an R_V810_8 reloc -
+	     is this reloc actually used?  */
+	  if (size != 2 && size != 4)
+	    abort ();
+
+	  if (extra_data_len == 0)
+	    {
+	      address = (f - frag_now->fr_literal) + insn_size - size;
+	    }
+	  else
+	    {
+	      address = (f - frag_now->fr_literal) + extra_data_len - size;
+	    }
+
+	  /* fprintf (stderr, "0x%x %d %ld\n", address, size, fixups[i].exp.X_add_number);  */
+	  fixP = fix_new_exp (frag_now, address, size,
+			      &fixups[i].exp,
+			      reloc_howto->pc_relative,
+			      reloc);
+
+	  fixP->tc_fix_data = (void *) operand;
+
+	  switch (reloc)
+	    {
+	    case BFD_RELOC_LO16:
+	    case BFD_RELOC_HI16:
+	    case BFD_RELOC_HI16_S:
+	      fixP->fx_no_overflow = 1;
+	      break;
+	    default:
+	      break;
+	    }
+	}
+      else
+	{
+	  fix_new_exp (frag_now,
+		       f - frag_now->fr_literal, 4,
+		       & fixups[i].exp,
+		       (operand->flags & V810_PCREL) != 0,
+		       (bfd_reloc_code_real_type) (fixups[i].opindex
+						   + (int) BFD_RELOC_UNUSED));
+	}
+    }
+
+  input_line_pointer = saved_input_line_pointer;
+}
+
+/* If while processing a fixup, a reloc really needs to be created
+   then it is done here.  */
+
+arelent *
+tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)
+{
+  arelent *reloc;
+
+  reloc		      = xmalloc (sizeof (arelent));
+  reloc->sym_ptr_ptr  = xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address      = fixp->fx_frag->fr_address + fixp->fx_where;
+
+  if (   fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY
+      || fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixp->fx_r_type == BFD_RELOC_V810_LONGCALL
+      || fixp->fx_r_type == BFD_RELOC_V810_LONGJUMP
+      || fixp->fx_r_type == BFD_RELOC_V810_ALIGN)
+    reloc->addend = fixp->fx_offset;
+  else
+    {
+      reloc->addend = fixp->fx_addnumber;
+    }
+
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
+
+  if (reloc->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    /* xgettext:c-format  */
+		    _("reloc %d not supported by object file format"),
+		    (int) fixp->fx_r_type);
+
+      xfree (reloc);
+
+      return NULL;
+    }
+
+  return reloc;
+}
+
+void
+v810_handle_align (fragS * frag)
+{
+  if (v810_relax
+      && frag->fr_type == rs_align
+      && frag->fr_address + frag->fr_fix > 0
+      && frag->fr_offset > 1
+      && now_seg != bss_section
+      && now_seg != v810_seg_table[SBSS_SECTION].s
+      && now_seg != v810_seg_table[ZBSS_SECTION].s)
+    fix_new (frag, frag->fr_fix, 2, & abs_symbol, frag->fr_offset, 0,
+	     BFD_RELOC_V810_ALIGN);
+}
+
+/* Return current size of variable part of frag.  */
+
+int
+md_estimate_size_before_relax (fragS *fragp, asection *seg ATTRIBUTE_UNUSED)
+{
+  if (fragp->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
+    abort ();
+
+  return md_relax_table[fragp->fr_subtype].rlx_length;
+}
+
+long
+v810_pcrel_from_section (fixS *fixp, segT section)
+{
+  /* If the symbol is undefined, or in a section other than our own,
+     or it is weak (in which case it may well be in another section,
+     then let the linker figure it out.  */
+  if (fixp->fx_addsy != (symbolS *) NULL
+      && (! S_IS_DEFINED (fixp->fx_addsy)
+	  || S_IS_WEAK (fixp->fx_addsy)
+	  || (S_GET_SEGMENT (fixp->fx_addsy) != section)))
+    return 0;
+
+  return fixp->fx_frag->fr_address + fixp->fx_where;
+}
+
+void
+md_apply_fix (fixS *fixP, valueT *valueP, segT seg ATTRIBUTE_UNUSED)
+{
+  valueT value = * valueP;
+  char *where;
+
+  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixP->fx_r_type == BFD_RELOC_V810_LONGCALL
+      || fixP->fx_r_type == BFD_RELOC_V810_LONGJUMP
+      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    {
+      fixP->fx_done = 0;
+      return;
+    }
+
+  if (fixP->fx_addsy == (symbolS *) NULL)
+    fixP->fx_addnumber = value,
+    fixP->fx_done = 1;
+
+  else if (fixP->fx_pcrel)
+    fixP->fx_addnumber = fixP->fx_offset;
+
+  else
+    {
+      value = fixP->fx_offset;
+      if (fixP->fx_subsy != (symbolS *) NULL)
+	{
+	  if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
+	    value -= S_GET_VALUE (fixP->fx_subsy);
+	  else
+	    /* We don't actually support subtracting a symbol.  */
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("expression too complex"));
+	}
+      fixP->fx_addnumber = value;
+    }
+
+  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
+    {
+      int opindex;
+      const struct v810_operand *operand;
+      unsigned long insn;
+      const char *errmsg = NULL;
+
+      opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;
+      operand = &v810_operands[opindex];
+
+      /* Fetch the instruction, insert the fully resolved operand
+	 value, and stuff the instruction back again.
+
+	 Note the instruction has been stored in little endian
+	 format!  */
+      where = fixP->fx_frag->fr_literal + fixP->fx_where;
+
+      if (fixP->fx_size > 2)
+	insn = bfd_getl32 ((unsigned char *) where);
+      else
+	insn = bfd_getl16 ((unsigned char *) where);
+
+      insn = v810_insert_operand (insn, operand, (offsetT) value,
+				  &errmsg);
+      if (errmsg)
+	as_warn_where (fixP->fx_file, fixP->fx_line, "%s", errmsg);
+
+      if (fixP->fx_size > 2)
+	bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
+      else
+	bfd_putl16 ((bfd_vma) insn, (unsigned char *) where);
+
+      if (fixP->fx_done)
+	/* Nothing else to do here.  */
+	return;
+
+      /* Determine a BFD reloc value based on the operand information.
+	 We are only prepared to turn a few of the operands into relocs.  */
+
+      if (operand->default_reloc == BFD_RELOC_NONE)
+	{
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("unresolved expression that must be resolved"));
+	  fixP->fx_done = 1;
+	  return;
+	}
+
+      {
+	fixP->fx_r_type = operand->default_reloc;
+      }
+    }
+  else if (fixP->fx_done)
+    {
+      /* We still have to insert the value into memory!  */
+      where = fixP->fx_frag->fr_literal + fixP->fx_where;
+
+      if (fixP->tc_fix_data != NULL
+          && ((struct v810_operand *) fixP->tc_fix_data)->insert != NULL)
+        {
+          const char * message = NULL;
+          struct v810_operand * operand = (struct v810_operand *) fixP->tc_fix_data;
+          unsigned long insn;
+
+          /* The variable "where" currently points at the exact point inside
+             the insn where we need to insert the value.  But we need to
+             extract the entire insn so we probably need to move "where"
+             back a few bytes.  */
+
+          if (fixP->fx_size == 2)
+            where -= 2;
+          else if (fixP->fx_size == 1)
+            where -= 3;
+
+          insn = bfd_getl32 ((unsigned char *) where);
+
+          /* Use the operand's insertion procedure, if present, in order to
+             make sure that the value is correctly stored in the insn.  */
+          insn = operand->insert (insn, (offsetT) value, & message);
+          /* Ignore message even if it is set.  */
+
+          bfd_putl32 ((bfd_vma) insn, (unsigned char *) where);
+        }
+      else
+        {
+	  switch (fixP->fx_r_type)
+	    {
+	    case BFD_RELOC_32:
+	      bfd_putl32 (value, (unsigned char *) where);
+	      break;
+
+	    case BFD_RELOC_16:
+	    case BFD_RELOC_HI16:
+	    case BFD_RELOC_HI16_S:
+	    case BFD_RELOC_LO16:
+	    case BFD_RELOC_V810_ZDA_16_16_OFFSET:
+	    case BFD_RELOC_V810_SDA_16_16_OFFSET:
+	      bfd_putl16 (value & 0xffff, (unsigned char *) where);
+	      break;
+
+	    case BFD_RELOC_8:
+	      *where = value & 0xff;
+	      break;
+
+	    case BFD_RELOC_V810_9_PCREL:
+	      bfd_putl16 ((value & 0x1fe)
+			  | (bfd_getl16 (where) & ~0x1fe), where);
+	      break;
+
+	    case BFD_RELOC_V810_26_PCREL:
+	      bfd_putl32 (((value & 0xfffe) << 16) | ((value & 0x3ff0000) >> 16)
+			  | (bfd_getl32 (where) & ~((0xfffe << 16) | (0x3ff0000 >> 16))), where);
+	      break;
+
+	    default:
+	      abort ();
+	    }
+        }
+    }
+}
+
+/* Parse a cons expression.  We have to handle hi(), lo(), etc
+   on the v810.  */
+
+void
+parse_cons_expression_v810 (expressionS *exp)
+{
+  const char *errmsg;
+  /* See if there's a reloc prefix like hi() we have to handle.  */
+  hold_cons_reloc = v810_reloc_prefix (NULL, &errmsg);
+
+  /* Do normal expression parsing.  */
+  expression (exp);
+}
+
+/* Create a fixup for a cons expression.  If parse_cons_expression_v810
+   found a reloc prefix, then we use that reloc, else we choose an
+   appropriate one based on the size of the expression.  */
+
+void
+cons_fix_new_v810 (fragS *frag,
+		   int where,
+		   int size,
+		   expressionS *exp)
+{
+  if (hold_cons_reloc == BFD_RELOC_UNUSED)
+    {
+      if (size == 4)
+	hold_cons_reloc = BFD_RELOC_32;
+      if (size == 2)
+	hold_cons_reloc = BFD_RELOC_16;
+      if (size == 1)
+	hold_cons_reloc = BFD_RELOC_8;
+    }
+
+  if (exp != NULL)
+    fix_new_exp (frag, where, size, exp, 0, hold_cons_reloc);
+  else
+    fix_new (frag, where, size, NULL, 0, 0, hold_cons_reloc);
+
+  hold_cons_reloc = BFD_RELOC_UNUSED;
+}
+
+bfd_boolean
+v810_fix_adjustable (fixS *fixP)
+{
+  if (fixP->fx_addsy == NULL)
+    return 1;
+
+  /* Don't adjust function names.  */
+  if (S_IS_FUNCTION (fixP->fx_addsy))
+    return 0;
+
+  /* We need the symbol name for the VTABLE entries.  */
+  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    return 0;
+
+  return 1;
+}
+
+int
+v810_force_relocation (struct fix *fixP)
+{
+  if (fixP->fx_r_type == BFD_RELOC_V810_LONGCALL
+      || fixP->fx_r_type == BFD_RELOC_V810_LONGJUMP)
+    return 1;
+
+  if (v810_relax
+      && (fixP->fx_pcrel
+	  || fixP->fx_r_type == BFD_RELOC_V810_ALIGN
+	  || fixP->fx_r_type == BFD_RELOC_V810_9_PCREL
+	  || fixP->fx_r_type == BFD_RELOC_V810_26_PCREL
+	  || fixP->fx_r_type >= BFD_RELOC_UNUSED))
+    return 1;
+
+  return generic_force_reloc (fixP);
+}
diff -Nbaur binutils-2.23.1/gas/config/tc-v810.h binutils-2.23.1-v810/gas/config/tc-v810.h
--- binutils-2.23.1/gas/config/tc-v810.h	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/config/tc-v810.h	2013-03-11 21:07:29 +0000
@@ -0,0 +1,84 @@
+/* tc-v810.h -- Header file for tc-v810.c.
+   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#define TC_V810
+
+#include "elf/v810.h"
+
+#define TARGET_BYTES_BIG_ENDIAN 0
+
+/* The target BFD architecture.  */
+#define TARGET_ARCH 		bfd_arch_v810
+
+/* The target BFD format.  */
+#define TARGET_FORMAT 		"elf32-v810"
+
+#define md_operand(x)
+
+#define tc_fix_adjustable(FIX) v810_fix_adjustable (FIX)
+extern bfd_boolean v810_fix_adjustable (struct fix *);
+
+#define TC_FORCE_RELOCATION(FIX) v810_force_relocation(FIX)
+extern int v810_force_relocation (struct fix *);
+
+#ifdef OBJ_ELF
+/* Values passed to md_apply_fix don't include the symbol value.  */
+#define MD_APPLY_SYM_VALUE(FIX) 0
+#endif
+
+/* Permit temporary numeric labels.  */
+#define LOCAL_LABELS_FB 1
+
+#define DIFF_EXPR_OK		/* foo-. gets turned into PC relative relocs.  */
+
+/* We don't need to handle .word strangely.  */
+#define WORKING_DOT_WORD
+
+#define md_number_to_chars number_to_chars_littleendian
+
+/* We need to handle lo(), hi(), etc etc in .hword, .word, etc
+   directives, so we have to parse "cons" expressions ourselves.  */
+#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) parse_cons_expression_v810 (EXP)
+extern void parse_cons_expression_v810 (expressionS *);
+
+#define TC_CONS_FIX_NEW cons_fix_new_v810
+extern void cons_fix_new_v810 (fragS *, int, int, expressionS *);
+
+#define TC_GENERIC_RELAX_TABLE md_relax_table
+extern const struct relax_type md_relax_table[];
+
+/* When relaxing, we need to generate
+   relocations for alignment directives.  */
+#define HANDLE_ALIGN(frag) v810_handle_align (frag)
+extern void v810_handle_align (fragS *);
+
+/* We need space in a frag's fixed size to allow for alignment when relaxing.  */
+#define TC_FX_SIZE_SLACK(FIX) 2
+
+#define MD_PCREL_FROM_SECTION(FIX, SEC) v810_pcrel_from_section (FIX, SEC)
+extern long v810_pcrel_from_section (struct fix *, asection *);
+
+#define DWARF2_LINE_MIN_INSN_LENGTH 2
+
+/* We need to record the operand involved when a pseudo-reloc is
+   processed so that the resulting value can be inserted correctly.  */
+#define TC_FIX_TYPE             void *
+#define TC_INIT_FIX_DATA(fixP)  (fixP)->tc_fix_data = NULL
diff -Nbaur binutils-2.23.1/gas/configure.tgt binutils-2.23.1-v810/gas/configure.tgt
--- binutils-2.23.1/gas/configure.tgt	2012-09-04 13:53:45 +0100
+++ binutils-2.23.1-v810/gas/configure.tgt	2013-03-09 17:59:21 +0000
@@ -86,6 +86,7 @@
   sparc*)		cpu_type=sparc arch=sparclite ;; # ??? See tc-sparc.c.
   tilegx*be)		cpu_type=tilegx endian=big ;;
   tilegx*)		cpu_type=tilegx endian=little ;;
+  v810*)		cpu_type=v810 ;;
   v850*)		cpu_type=v850 ;;
   x86_64*)		cpu_type=i386 arch=x86_64;;
   xgate)		cpu_type=xgate ;;
@@ -421,6 +422,9 @@
 
   tilepro-*-* | tilegx*-*-*)		fmt=elf ;;
 
+  v810-*-*)					fmt=elf ;;
+  v830-*-*)					fmt=elf ;;
+
   v850*-*-*)				fmt=elf ;;
 
   vax-*-netbsdelf*)			fmt=elf em=nbsd ;;
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/arith.s binutils-2.23.1-v810/gas/testsuite/gas/v810/arith.s
--- binutils-2.23.1/gas/testsuite/gas/v810/arith.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/arith.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,24 @@
+
+	.text
+	.global arith_opcodes
+arith_opcodes:
+	add r5,r6
+	add 5,r6
+	addi 7,r5,r6
+	divh r5,r6
+	mulh r5,r6
+	mulh 5,r6
+	mulhi 7,r5,r6
+	sar r5,r6
+	sar 31,r6
+	satadd r5,r6
+	satadd 5,r6
+	satsub r5,r6
+	satsubi 7,r5,r6
+	satsubr r5,r6
+	shl r5,r6
+	shl 31,r6
+	shr r5,r6
+	shr 31,r6
+	sub r5,r6
+	subr r5,r6
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/basic.exp binutils-2.23.1-v810/gas/testsuite/gas/v810/basic.exp
--- binutils-2.23.1/gas/testsuite/gas/v810/basic.exp	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/basic.exp	2013-03-09 17:59:21 +0000
@@ -0,0 +1,438 @@
+# Copyright (C) 1996 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+# Please email any bugs, comments, and/or additions to this file to:
+# DejaGnu@cygnus.com
+
+# Written by Cygnus Support.
+
+proc do_arith {} {
+    set testname "arith.s: Arithmetic operations"
+    set x 0
+
+    gas_start "arith.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    # -re "^ +\[0-9\]+ 0000 489A0000\[^\n\]*\n"	{ set x [expr $x+1] }
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 C531\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0002 4532\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 05360700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 4530\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000a E530\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000c E532\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000e E5360700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0012 E537A000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0016 BF32\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0018 C530\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001a 2532\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001c A530\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001e 65360700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0022 8530\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0024 E537C000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0028 DF32\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 002a E5378000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 002e 9F32\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0030 A531\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0032 8531\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==20] then { pass $testname } else { fail $testname }
+}
+
+proc do_bit {} {
+    set testname "bit.s: bit operations"
+    set x 0
+
+    gas_start "bit.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 C6AF1000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 C66F1000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 C62F1000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000c C6EF1000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==4] then { pass $testname } else { fail $testname }
+}
+
+proc do_branch {} {
+    set testname "branch.s: branch operations"
+    set x 0
+
+    gas_start "branch.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 8F05\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0002 FEFD\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 E6FD\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0006 D7FD\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 CBFD\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000a B9FD\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000c A1FD\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000e 93FD\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0010 82FD\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0012 FAF5\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0014 E0F5\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0016 D8F5\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0018 C4F5\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001a BCF5\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001c A1F5\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001e 99F5\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0020 82F5\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0022 FAED\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0024 E5ED\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0026 DDED\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==20] then { pass $testname } else { fail $testname }
+}
+
+proc do_compare {} {
+    set testname "compare.s: compare operations"
+    set x 0
+
+    gas_start "compare.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 E531\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0002 6532\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 E02F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 E82F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000c E12F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0010 E12F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0014 E92F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0018 E92F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001c E22F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0020 EA2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0024 E32F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0028 EB2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 002c E42F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0030 E42F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0034 EC2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0038 EC2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 003c E52F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0040 ED2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0044 E62F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0048 EE2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 004c E72F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0050 EF2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0054 6531\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==23] then { pass $testname } else { fail $testname }
+}
+
+proc do_jumps {} {
+    set testname "jumps.s: jumps operations"
+    set x 0
+
+    gas_start "jumps.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 802F0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 6500\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0006 BF07FAFF\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==3] then { pass $testname } else { fail $testname }
+}
+
+proc do_logical {} {
+    set testname "logical.s: logical operations"
+    set x 0
+
+    gas_start "logical.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 4531\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0002 C5360700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0006 2530\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 0531\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000a 85360700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000e 2531\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0010 A5360700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==7] then { pass $testname } else { fail $testname }
+}
+
+proc do_mem {} {
+    set testname "mem.s: memory operations"
+    set x 0
+
+    gas_start "mem.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 05370500\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 25370400\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 25370500\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000c 4033\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000e 4034\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0010 4035\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0012 462F0500\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0016 662F0400\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001a 662F0500\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001e C033\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0020 C034\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0022 4135\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==12] then { pass $testname } else { fail $testname }
+}
+
+proc do_misc {} {
+    set testname "misc.s: misc operations"
+    set x 0
+
+    gas_start "misc.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 E0076001\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 E0876001\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 E0072001\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000c 0000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 000e E0074001\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0012 E0070001\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0016 FF070001\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001a E72F2000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 001e E53F4000\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==9] then { pass $testname } else { fail $testname }
+}
+
+proc do_move {} {
+    set testname "move.s: move operations"
+    set x 0
+
+    gas_start "move.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 0530\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0002 0532\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 25360700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 45360700\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==4] then { pass $testname } else { fail $testname }
+}
+
+proc do_hilo {} {
+    set testname "hilo.s: hilo tests"
+    set x 0
+
+    gas_start "hilo.s" "-al"
+
+    # Instead of having a variable for each match string just increment the
+    # total number of matches seen.  That's simpler when testing large numbers
+    # of instructions (as these tests to).
+    while 1 {
+	expect {
+	    -re "^ +\[0-9\]+ 0000 200EEFBE\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0004 410EAEDE\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "^ +\[0-9\]+ 0008 410EADDE\[^\n\]*\n"	{ set x [expr $x+1] }
+	    -re "\[^\n\]*\n"				{ }
+	    timeout				{ perror "timeout\n"; break }
+	    eof					{ break }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    gas_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==3] then { pass $testname } else { fail $testname }
+}
+
+
+proc do_simple_reloc_tests {} {
+    set testname "reloc.s: Test for proper relocations (part 2)"
+    set x 0
+
+    if [gas_test_old "reloc.s" "" "Test for proper relocation (part 1)"] then {
+	objdump_start_no_subdir "a.out" "-r"
+
+	while 1 {
+	    expect {
+		-re "^00000002\[^\n\]*R_V850_LO16\[^\n\]*\n"
+			{ set x [expr $x+1] }
+		-re "^00000006\[^\n\]*R_V850_HI16_S\[^\n\]*\n"
+			{ set x [expr $x+1] }
+		-re "^0000000a\[^\n\]*R_V850_HI16\[^\n\]*\n"
+			{ set x [expr $x+1] }
+		-re "^0000000e\[^\n\]*R_V850_ZDA_16_16_OFFSET\[^\n\]*\n"
+			{ set x [expr $x+1] }
+		-re "^00000012\[^\n\]*R_V850_TDA_16_16_OFFSET\[^\n\]*\n"
+			{ set x [expr $x+1] }
+		-re "^00000016\[^\n\]*R_V850_SDA_16_16_OFFSET\[^\n\]*\n"
+			{ set x [expr $x+1] }
+		-re "\[^\n\]*\n"				{ }
+		timeout			{ perror "timeout\n"; break }
+		eof				{ break }
+	    }
+	}
+    }
+
+    # This was intended to do any cleanup necessary.  It kinda looks like it
+    # isn't needed, but just in case, please keep it in for now.
+    objdump_finish
+
+    # Did we find what we were looking for?  If not, flunk it.
+    if [expr $x==6] then { pass $testname } else { fail $testname }
+}
+
+if [istarget v850*-*-*] then {
+    # Test the basic instruction parser.
+    do_arith
+    do_bit
+    do_branch
+    do_compare
+    do_jumps
+    do_logical
+    do_mem
+    do_misc
+    do_move
+
+    # Make sure we handle lo() hi() and hi0() correctly.
+    do_hilo
+
+    # Check for proper relocs on lo, hi, hi0, zdaoff, tdaoff and sdaoff
+    # expressions
+    do_simple_reloc_tests
+
+    gas_test "hilo2.s" "" "" "hi/lo regression test"
+    gas_test "fepsw.s" "" "" "eqsw regression test"
+
+    gas_test_error "range.s" "-mwarn-signed-overflow" "Check for range error on byte load/store"
+}
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/bit.s binutils-2.23.1-v810/gas/testsuite/gas/v810/bit.s
--- binutils-2.23.1/gas/testsuite/gas/v810/bit.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/bit.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,8 @@
+
+	.text
+	.global bit
+bit:
+	clr1 5,16[r6]
+	not1 5,16[r6]
+	set1 5,16[r6]
+	tst1 5,16[r6]
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/branch.s binutils-2.23.1-v810/gas/testsuite/gas/v810/branch.s
--- binutils-2.23.1/gas/testsuite/gas/v810/branch.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/branch.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,24 @@
+
+	.text
+	.global bcc
+bcc:
+	bgt bcc
+	bge bcc
+	blt bcc
+	ble bcc
+	bh bcc
+	bnl bcc
+	bl bcc
+	bnh bcc
+	be bcc
+	bne bcc
+	bv bcc
+	bnv bcc
+	bn bcc
+	bp bcc
+	bc bcc
+	bnc bcc
+	bz bcc
+	bnz bcc
+	br bcc
+	bsa bcc
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/compare.s binutils-2.23.1-v810/gas/testsuite/gas/v810/compare.s
--- binutils-2.23.1/gas/testsuite/gas/v810/compare.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/compare.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,28 @@
+
+	.text
+	.global compare
+compare:
+	cmp r5,r6
+	cmp 5,r6
+	setf v,r5
+	setf nv,r5
+	setf c,r5
+	setf l,r5
+	setf nc,r5
+	setf nl,r5
+	setf z,r5
+	setf nz,r5
+	setf nh,r5
+	setf h,r5
+	setf s,r5
+	setf n,r5
+	setf ns,r5
+	setf p,r5
+	setf t,r5
+	setf sa,r5
+	setf lt,r5
+	setf ge,r5
+	setf le,r5
+	setf gt,r5
+	tst r5,r6
+	
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/fepsw.s binutils-2.23.1-v810/gas/testsuite/gas/v810/fepsw.s
--- binutils-2.23.1/gas/testsuite/gas/v810/fepsw.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/fepsw.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,2 @@
+	.text
+	ldsr r17,fepsw
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/hilo.s binutils-2.23.1-v810/gas/testsuite/gas/v810/hilo.s
--- binutils-2.23.1/gas/testsuite/gas/v810/hilo.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/hilo.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,5 @@
+
+	.text
+	movea lo(0xdeadbeef),r0,r1
+	movhi hi(0xdeadbeef),r1,r1
+	movhi hi0(0xdeadbeef),r1,r1
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/hilo2.s binutils-2.23.1-v810/gas/testsuite/gas/v810/hilo2.s
--- binutils-2.23.1/gas/testsuite/gas/v810/hilo2.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/hilo2.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,4 @@
+	.text
+	.org 0x10000
+	movea hi(blah),r0,r1
+blah:
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/jumps.s binutils-2.23.1-v810/gas/testsuite/gas/v810/jumps.s
--- binutils-2.23.1/gas/testsuite/gas/v810/jumps.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/jumps.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,8 @@
+
+	.text
+	.global jumps
+jumps:
+	jarl jumps,r5
+	jmp [r5]
+	jr jumps
+	
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/logical.s binutils-2.23.1-v810/gas/testsuite/gas/v810/logical.s
--- binutils-2.23.1/gas/testsuite/gas/v810/logical.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/logical.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,11 @@
+
+	.text
+	.global logicals
+logicals:
+	and r5,r6
+	andi 7,r5,r6
+	not r5,r6
+	or r5,r6
+	ori 7,r5,r6
+	xor r5,r6
+	xori 7,r5,r6
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/mem.s binutils-2.23.1-v810/gas/testsuite/gas/v810/mem.s
--- binutils-2.23.1/gas/testsuite/gas/v810/mem.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/mem.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,16 @@
+
+	.text
+	.global memory
+memory:
+	ld.b 5[r5],r6
+	ld.h 4[r5],r6
+	ld.w 4[r5],r6
+	sld.b 64[ep],r6
+	sld.h 128[ep],r6
+	sld.w 128[ep],r6
+	st.b r5,5[r6]
+	st.h r5,4[r6]
+	st.w r5,4[r6]
+	sst.b r6,64[ep]
+	sst.h r6,128[ep]
+	sst.w r6,128[ep]
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/misc.s binutils-2.23.1-v810/gas/testsuite/gas/v810/misc.s
--- binutils-2.23.1/gas/testsuite/gas/v810/misc.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/misc.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,13 @@
+
+	.text
+	.global misc
+misc:
+	di
+	ei
+	halt
+	nop
+	reti
+	trap 0
+	trap 31
+	ldsr r7,psw
+	stsr psw,r7
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/move.s binutils-2.23.1-v810/gas/testsuite/gas/v810/move.s
--- binutils-2.23.1/gas/testsuite/gas/v810/move.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/move.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,8 @@
+
+	.text
+	.global move
+move:
+	mov r5,r6
+	mov 5,r6
+	movea 7,r5,r6
+	movhi 7,r5,r6
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/range.s binutils-2.23.1-v810/gas/testsuite/gas/v810/range.s
--- binutils-2.23.1/gas/testsuite/gas/v810/range.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/range.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,2 @@
+	.text
+	ld.b 0xff62[r0],r0
diff -Nbaur binutils-2.23.1/gas/testsuite/gas/v810/reloc.s binutils-2.23.1-v810/gas/testsuite/gas/v810/reloc.s
--- binutils-2.23.1/gas/testsuite/gas/v810/reloc.s	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/gas/testsuite/gas/v810/reloc.s	2013-03-09 17:59:21 +0000
@@ -0,0 +1,7 @@
+	.text
+	movea lo(foo),r0,r1
+	movhi hi(foo),r1,r1
+	movhi hi0(foo),r1,r1
+	movea zdaoff(_foo),r0,r1
+	movhi tdaoff(_foo),ep,r1
+	movhi sdaoff(_foo),gp,r1
diff -Nbaur binutils-2.23.1/include/dis-asm.h binutils-2.23.1-v810/include/dis-asm.h
--- binutils-2.23.1/include/dis-asm.h	2012-09-04 13:53:46 +0100
+++ binutils-2.23.1-v810/include/dis-asm.h	2013-03-09 17:59:21 +0000
@@ -292,6 +292,7 @@
 extern int print_insn_tic80		(bfd_vma, disassemble_info *);
 extern int print_insn_tilegx		(bfd_vma, disassemble_info *);
 extern int print_insn_tilepro		(bfd_vma, disassemble_info *);
+extern int print_insn_v810		(bfd_vma, disassemble_info *);
 extern int print_insn_v850		(bfd_vma, disassemble_info *);
 extern int print_insn_vax		(bfd_vma, disassemble_info *);
 extern int print_insn_w65		(bfd_vma, disassemble_info *);
diff -Nbaur binutils-2.23.1/include/elf/common.h binutils-2.23.1-v810/include/elf/common.h
--- binutils-2.23.1/include/elf/common.h	2012-09-04 13:53:47 +0100
+++ binutils-2.23.1-v810/include/elf/common.h	2013-03-09 17:59:21 +0000
@@ -372,6 +372,9 @@
 /* V850 backend magic number.  Written in the absense of an ABI.  */
 #define EM_CYGNUS_V850		0x9080
 
+/* V810 backend magic number.  No EABI available.  */
+#define EM_V810		0x9081
+
 /* old S/390 backend magic number. Written in the absence of an ABI.  */
 #define EM_S390_OLD		0xa390
 
diff -Nbaur binutils-2.23.1/include/elf/v810.h binutils-2.23.1-v810/include/elf/v810.h
--- binutils-2.23.1/include/elf/v810.h	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/include/elf/v810.h	2013-03-10 20:34:38 +0000
@@ -0,0 +1,96 @@
+/* V810 ELF support for BFD.
+   Copyright 1997, 1998, 2000, 2002, 2003, 2004, 2007, 2008, 2010
+   Free Software Foundation, Inc.
+   Created by Michael Meissner, Cygnus Support <meissner@cygnus.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* This file holds definitions specific to the MIPS ELF ABI.  Note
+   that most of this is not actually implemented by BFD.  */
+
+#ifndef _ELF_V810_H
+#define _ELF_V810_H
+
+/* Processor specific flags for the ELF header e_flags field.  */
+
+/* Four bit V810 architecture field.  */
+#define EF_V810_ARCH		0xf0000000
+
+/* v810 code.  */
+#define E_V810_ARCH		0x00000000
+
+/* v830 code.  */
+#define E_V830_ARCH		0x10000000
+
+/* Flags for the st_other field.  */
+#define V810_OTHER_SDA		0x10	/* Symbol had SDA relocations.  */
+#define V810_OTHER_ZDA		0x20	/* Symbol had ZDA relocations.  */
+#define V810_OTHER_ERROR	0x40	/* Symbol had an error reported.  */
+
+/* V810 relocations.  */
+#include "elf/reloc-macros.h"
+
+START_RELOC_NUMBERS (v810_reloc_type)
+     RELOC_NUMBER (R_V810_NONE, 0)
+     RELOC_NUMBER (R_V810_9_PCREL, 1)
+     RELOC_NUMBER (R_V810_26_PCREL, 2)
+     RELOC_NUMBER (R_V810_HI16_S, 3)
+     RELOC_NUMBER (R_V810_HI16, 4)
+     RELOC_NUMBER (R_V810_LO16, 5)
+     RELOC_NUMBER (R_V810_32, 6)
+     RELOC_NUMBER (R_V810_16, 7)
+     RELOC_NUMBER (R_V810_8, 8)
+     RELOC_NUMBER (R_V810_SDA_16_16_OFFSET, 9)		/* For ld.[w,h,b], st.[w,h,b], movea, movhi */
+     RELOC_NUMBER (R_V810_ZDA_16_16_OFFSET, 10)		/* For ld.[w,h,b], st.[w,h,b], movea, movhi */
+     RELOC_NUMBER (R_V810_GNU_VTINHERIT, 11)
+     RELOC_NUMBER (R_V810_GNU_VTENTRY, 12)
+     RELOC_NUMBER (R_V810_LONGCALL, 13)
+     RELOC_NUMBER (R_V810_LONGJUMP, 14)
+     RELOC_NUMBER (R_V810_ALIGN, 15)
+
+END_RELOC_NUMBERS (R_V810_max)
+
+
+/* Processor specific section indices.  These sections do not actually
+   exist.  Symbols with a st_shndx field corresponding to one of these
+   values have a special meaning.  */
+
+/* Small data area common symbol.  */
+#define SHN_V810_SCOMMON	SHN_LORESERVE
+
+/* Zero data area common symbol.  */
+#define SHN_V810_ZCOMMON	(SHN_LORESERVE + 1)
+
+
+/* Processor specific section types.  */
+
+/* Section contains the .scommon data.  */
+#define SHT_V810_SCOMMON	0x70000000
+
+/* Section contains the .scommon data.  */
+#define SHT_V810_ZCOMMON	0x70000001
+
+/* Processor specific section flags.  */
+
+/* This section must be in the small data area (pointed to by GP).  */
+#define SHF_V810_GPREL		0x10000000
+
+/* This section must be in the zero data area (pointed to by R0).  */
+#define SHF_V810_R0REL		0x20000000
+
+#endif /* _ELF_V810_H */
diff -Nbaur binutils-2.23.1/include/opcode/v810.h binutils-2.23.1-v810/include/opcode/v810.h
--- binutils-2.23.1/include/opcode/v810.h	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/include/opcode/v810.h	2013-03-12 16:10:05 +0000
@@ -0,0 +1,160 @@
+/* v810.h -- Header file for NEC V810 opcode table
+   Copyright 1996, 1997, 2001, 2003, 2010 Free Software Foundation, Inc.
+   Written by J.T. Conklin, Cygnus Support
+
+   This file is part of GDB, GAS, and the GNU binutils.
+
+   GDB, GAS, and the GNU binutils are free software; you can redistribute
+   them and/or modify them under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either version 3,
+   or (at your option) any later version.
+
+   GDB, GAS, and the GNU binutils are distributed in the hope that they
+   will be useful, but WITHOUT ANY WARRANTY; without even the implied
+   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+   the GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#ifndef V810_H
+#define V810_H
+
+/* The opcode table is an array of struct v810_opcode.  */
+
+struct v810_opcode
+{
+  /* The opcode name.  */
+  const char *name;
+
+  /* The opcode itself.  Those bits which will be filled in with
+     operands are zeroes.  */
+  unsigned long opcode;
+
+  /* The opcode mask.  This is used by the disassembler.  This is a
+     mask containing ones indicating those bits which must match the
+     opcode field, and zeroes indicating those bits which need not
+     match (and are presumably filled in by operands).  */
+  unsigned long mask;
+
+  /* An array of operand codes.  Each code is an index into the
+     operand table.  They appear in the order which the operands must
+     appear in assembly code, and are terminated by a zero.  */
+  unsigned char operands[8];
+
+  /* Which (if any) operand is a memory operand.  */
+  unsigned int memop;
+
+  /* Target processor(s).  A bit field of processors which support
+     this instruction.  Note a bit field is used as some instructions
+     are available on multiple, different processor types, whereas
+     other instructions are only available on one specific type.  */
+  unsigned int processors;
+};
+
+/* Values for the processors field in the v810_opcode structure.  */
+#define PROCESSOR_MASK		0x3
+#define PROCESSOR_V810		(1 << 0)		/* Just the V810.  */
+#define PROCESSOR_ALL		PROCESSOR_MASK		/* Any processor.  */
+#define PROCESSOR_V830		(1 << 1)		/* Just the V830.  */
+#define PROCESSOR_NOT_V830	(PROCESSOR_ALL & (~ PROCESSOR_V830))	/* Any processor except the V830.  */
+#define SET_PROCESSOR_MASK(mask,set)	((mask) = ((mask) & ~PROCESSOR_MASK) | (set))
+
+/* The table itself is sorted by major opcode number, and is otherwise
+   in the order in which the disassembler should consider
+   instructions.  */
+extern const struct v810_opcode v810_opcodes[];
+extern const int v810_num_opcodes;
+
+
+/* The operands table is an array of struct v810_operand.  */
+
+struct v810_operand
+{
+  /* The number of bits in the operand.  */
+  /* If this value is -1 then the operand's bits are in a discontinous
+     distribution in the instruction. */
+  int bits;
+
+  /* (bits >= 0):  How far the operand is left shifted in the instruction.  */
+  /* (bits == -1): Bit mask of the bits in the operand.  */
+  int shift;
+
+  /* Insertion function.  This is used by the assembler.  To insert an
+     operand value into an instruction, check this field.
+
+     If it is NULL, execute
+         i |= (op & ((1 << o->bits) - 1)) << o->shift;
+     (i is the instruction which we are filling in, o is a pointer to
+     this structure, and op is the opcode value; this assumes twos
+     complement arithmetic).
+
+     If this field is not NULL, then simply call it with the
+     instruction and the operand value.  It will return the new value
+     of the instruction.  If the ERRMSG argument is not NULL, then if
+     the operand value is illegal, *ERRMSG will be set to a warning
+     string (the operand will be inserted in any case).  If the
+     operand value is legal, *ERRMSG will be unchanged (most operands
+     can accept any value).  */
+  unsigned long (* insert)
+    (unsigned long instruction, long op, const char ** errmsg);
+
+  /* Extraction function.  This is used by the disassembler.  To
+     extract this operand type from an instruction, check this field.
+
+     If it is NULL, compute
+         op = o->bits == -1 ? ((i) & o->shift) : ((i) >> o->shift) & ((1 << o->bits) - 1);
+	 if (o->flags & V810_OPERAND_SIGNED)
+	     op = (op << (32 - o->bits)) >> (32 - o->bits);
+     (i is the instruction, o is a pointer to this structure, and op
+     is the result; this assumes twos complement arithmetic).
+
+     If this field is not NULL, then simply call it with the
+     instruction value.  It will return the value of the operand.  If
+     the INVALID argument is not NULL, *INVALID will be set to
+     non-zero if this operand type can not actually be extracted from
+     this operand (i.e., the instruction does not match).  If the
+     operand is valid, *INVALID will not be changed.  */
+  unsigned long (* extract) (unsigned long instruction, int * invalid);
+
+  /* One bit syntax flags.  */
+  int flags;
+
+  int default_reloc;
+};
+
+/* Elements in the table are retrieved by indexing with values from
+   the operands field of the v810_opcodes table.  */
+
+extern const struct v810_operand v810_operands[];
+
+/* Values defined for the flags field of a struct v810_operand.  */
+
+/* This operand names a general purpose register.  */
+#define V810_OPERAND_REG	0x01
+
+/* This operand names a system register.  */
+#define V810_OPERAND_SRG	0x02
+
+/* This operand names a condition code used in the setf instruction.  */
+#define V810_OPERAND_CC		0x04
+
+/* This is a relaxable operand.   Only used for D9->D26 branch relaxing
+   right now.  We may need others in the future (or maybe handle them like
+   promoted operands on the mn10300?).  */
+#define V810_OPERAND_RELAX	0x08
+
+/* This operand takes signed values.  */
+#define V810_OPERAND_SIGNED	0x10
+
+/* This operand is a displacement.  */
+#define V810_OPERAND_DISP	0x20
+
+/* This operand is a PC displacement.  */
+#define V810_PCREL		0x40
+
+extern int v810_msg_is_out_of_range (const char * msg);
+
+#endif /* V810_H */
diff -Nbaur binutils-2.23.1/ld/Makefile.am binutils-2.23.1-v810/ld/Makefile.am
--- binutils-2.23.1/ld/Makefile.am	2012-09-04 13:53:47 +0100
+++ binutils-2.23.1-v810/ld/Makefile.am	2013-03-09 17:59:22 +0000
@@ -451,6 +451,7 @@
 	etic4xcoff.c \
 	etic54xcoff.c \
 	etic80coff.c \
+	ev810.c \
 	ev850.c \
 	evanilla.c \
 	evax.c \
@@ -1914,6 +1915,9 @@
 etic80coff.c: $(srcdir)/emulparams/tic80coff.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic80coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} tic80coff "$(tdir_tic80coff)"
+ev810.c: $(srcdir)/emulparams/v810.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/v810.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} v810 "$(tdir_v810)"
 ev850.c: $(srcdir)/emulparams/v850.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/v850.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} v850 "$(tdir_v850)"
diff -Nbaur binutils-2.23.1/ld/Makefile.in binutils-2.23.1-v810/ld/Makefile.in
--- binutils-2.23.1/ld/Makefile.in	2012-09-04 13:53:47 +0100
+++ binutils-2.23.1-v810/ld/Makefile.in	2013-03-09 17:59:22 +0000
@@ -758,6 +758,7 @@
 	etic4xcoff.c \
 	etic54xcoff.c \
 	etic80coff.c \
+	ev810.c \
 	ev850.c \
 	evanilla.c \
 	evax.c \
@@ -1416,6 +1417,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic4xcoff.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic54xcoff.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic80coff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ev810.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ev850.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/evanilla.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/evax.Po@am__quote@
@@ -3384,6 +3386,9 @@
 etic80coff.c: $(srcdir)/emulparams/tic80coff.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic80coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} tic80coff "$(tdir_tic80coff)"
+ev810.c: $(srcdir)/emulparams/v810.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/v810.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} v810 "$(tdir_v810)"
 ev850.c: $(srcdir)/emulparams/v850.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/v850.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} v850 "$(tdir_v850)"
diff -Nbaur binutils-2.23.1/ld/configure.tgt binutils-2.23.1-v810/ld/configure.tgt
--- binutils-2.23.1/ld/configure.tgt	2012-09-04 13:53:47 +0100
+++ binutils-2.23.1-v810/ld/configure.tgt	2013-03-09 17:59:22 +0000
@@ -697,6 +697,10 @@
 			targ_extra_emuls="elf64tilegx elf32tilegx elf32tilegx_be"
 			targ_extra_libpath=$targ_extra_emuls ;;
 tilepro-*-*)		targ_emul=elf32tilepro ;;
+v810-*-*)		targ_emul=v810
+			;;
+v830-*-*)		targ_emul=v830
+			;;
 v850*-*-*)		targ_emul=v850
 			;;
 vax-dec-ultrix* | vax-dec-bsd*) targ_emul=vax ;;
diff -Nbaur binutils-2.23.1/ld/emulparams/v810.sh binutils-2.23.1-v810/ld/emulparams/v810.sh
--- binutils-2.23.1/ld/emulparams/v810.sh	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/ld/emulparams/v810.sh	2013-03-09 17:59:22 +0000
@@ -0,0 +1,13 @@
+MACHINE=
+SCRIPT_NAME=v810
+OUTPUT_FORMAT="elf32-v810"
+TEXT_START_ADDR=0x8000
+ZDATA_START_ADDR=0x160
+ROZDATA_START_ADDR="ALIGN (4)"
+SDATA_START_ADDR="ALIGN (4)"
+ROSDATA_START_ADDR="ALIGN (4)"
+ARCH=v810
+MAXPAGESIZE=256
+ENTRY=_start
+EMBEDDED=yes
+TEMPLATE_NAME=elf32
diff -Nbaur binutils-2.23.1/ld/scripttempl/v810.sc binutils-2.23.1-v810/ld/scripttempl/v810.sc
--- binutils-2.23.1/ld/scripttempl/v810.sc	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/ld/scripttempl/v810.sc	2013-03-09 17:59:22 +0000
@@ -0,0 +1,230 @@
+cat << EOF
+OUTPUT_FORMAT("elf32-v810", "elf32-v810",
+	      "elf32-v810")
+OUTPUT_ARCH(v810)
+ENTRY(_start)
+SEARCH_DIR(.);
+SECTIONS
+{
+  /* This saves a little space in the ELF file, since the zda starts
+     at a higher location that the ELF headers take up.  */
+
+  .zdata ${ZDATA_START_ADDR} :
+  {
+	*(.zdata)
+	*(.zbss)
+	*(reszdata)
+	*(.zcommon)
+  }
+
+  /* This is the read only part of the zero data area.
+     Having it as a seperate section prevents its
+     attributes from being inherited by the zdata
+     section.  Specifically it prevents the zdata
+     section from being marked READONLY.  */
+
+  .rozdata ${ROZDATA_START_ADDR} :
+  {
+	*(.rozdata)
+	*(romzdata)
+	*(romzbss)
+  }
+
+  /* Read-only sections, merged into text segment.  */
+  . = ${TEXT_START_ADDR};
+  .interp	: { *(.interp) }
+  .hash		: { *(.hash) }
+  .dynsym	: { *(.dynsym) }
+  .dynstr	: { *(.dynstr) }
+  .rel.text	: { *(.rel.text) }
+  .rela.text	: { *(.rela.text) }
+  .rel.data	: { *(.rel.data) }
+  .rela.data	: { *(.rela.data) }
+  .rel.rodata	: { *(.rel.rodata) }
+  .rela.rodata	: { *(.rela.rodata) }
+  .rel.gcc_except_table : { *(.rel.gcc_except_table) }
+  .rela.gcc_except_table : { *(.rela.gcc_except_table) }
+  .rel.got	: { *(.rel.got) }
+  .rela.got	: { *(.rela.got) }
+  .rel.ctors	: { *(.rel.ctors) }
+  .rela.ctors	: { *(.rela.ctors) }
+  .rel.dtors	: { *(.rel.dtors) }
+  .rela.dtors	: { *(.rela.dtors) }
+  .rel.init	: { *(.rel.init) }
+  .rela.init	: { *(.rela.init) }
+  .rel.fini	: { *(.rel.fini) }
+  .rela.fini	: { *(.rela.fini) }
+  .rel.bss	: { *(.rel.bss) }
+  .rela.bss	: { *(.rela.bss) }
+  .rel.plt	: { *(.rel.plt) }
+  .rela.plt	: { *(.rela.plt) }
+  .init		: { KEEP (*(.init)) } =0
+  .plt		: { *(.plt) }
+
+  .text		:
+  {
+    *(.text)
+    ${RELOCATING+*(.text.*)}
+    
+    /* .gnu.warning sections are handled specially by elf32.em.  */
+    *(.gnu.warning)
+    *(.gnu.linkonce.t*)
+  } =0
+
+  ${RELOCATING+_etext = .;}
+  ${RELOCATING+PROVIDE (etext = .);}
+
+   /* This is special code area at the end of the normal text section.
+      It contains a small lookup table at the start followed by the
+      code pointed to by entries in the lookup table.  */
+
+  .call_table_data ${CALL_TABLE_START_ADDR} :
+  {
+    ${RELOCATING+PROVIDE(__ctbp = .);}
+    *(.call_table_data)
+  } = 0xff   /* Fill gaps with 0xff.  */
+  
+  .call_table_text :
+  {
+    *(.call_table_text)
+  }
+
+  .fini		: { KEEP (*(.fini)) } =0
+  .rodata	: { *(.rodata) ${RELOCATING+*(.rodata.*)} *(.gnu.linkonce.r*) }
+  .rodata1	: { *(.rodata1) }
+
+  .data		:
+  {
+    *(.data)
+    ${RELOCATING+*(.data.*)}
+    *(.gnu.linkonce.d*)
+    CONSTRUCTORS
+  }
+  .data1	: { *(.data1) }
+  .ctors	:
+  {
+    ${CONSTRUCTING+___ctors = .;}
+    KEEP (*(EXCLUDE_FILE (*crtend.o) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*crtend(.ctors))
+    ${CONSTRUCTING+___ctors_end = .;}
+  }
+  .dtors	:
+  {
+    ${CONSTRUCTING+___dtors = .;}
+    KEEP (*(EXCLUDE_FILE (*crtend.o) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*crtend.o(.dtors))
+    ${CONSTRUCTING+___dtors_end = .;}
+  }
+  .jcr		:
+  {
+    KEEP (*(.jcr))
+  }
+
+  .gcc_except_table : { *(.gcc_except_table) }
+
+  .got		: { *(.got.plt) *(.got) }
+  .dynamic	: { *(.dynamic) }
+
+  .tdata ${TDATA_START_ADDR} :
+  {
+	${RELOCATING+PROVIDE (__ep = .);}
+	*(.tbyte)
+	*(.tcommon_byte)
+	*(.tdata)
+	*(.tbss)
+	*(.tcommon)
+  }
+
+  /* We want the small data sections together, so single-instruction offsets
+     can access them all, and initialized data all before uninitialized, so
+     we can shorten the on-disk segment size.  */
+     
+  .sdata ${SDATA_START_ADDR} :
+  {
+	${RELOCATING+PROVIDE (__gp = . + 0x8000);}
+	*(.sdata)
+   }
+
+  /* See comment about .rozdata. */
+  .rosdata ${ROSDATA_START_ADDR} :
+  {
+	*(.rosdata)
+  }
+
+  /* We place the .sbss data section AFTER the .rosdata section, so that
+     it can directly preceed the .bss section.  This allows runtime startup
+     code to initialise all the zero-data sections by simply taking the
+     value of '_edata' and zeroing until it reaches '_end'.  */
+     
+  .sbss :
+  {
+	${RELOCATING+__sbss_start = .;}
+	*(.sbss)
+	*(.scommon)
+  }
+
+  ${RELOCATING+_edata  = DEFINED (__sbss_start) ? __sbss_start : . ;}
+  ${RELOCATING+PROVIDE (edata = _edata);}
+
+  .bss       :
+  {
+	${RELOCATING+__bss_start = DEFINED (__sbss_start) ? __sbss_start : . ;}
+	${RELOCATING+__real_bss_start = . ;}
+	*(.dynbss)
+	*(.bss)
+	*(COMMON)
+  }
+
+  ${RELOCATING+_end = . ;}
+  ${RELOCATING+PROVIDE (end = .);}
+
+  /* Stabs debugging sections.  */
+  .stab 0		: { *(.stab) }
+  .stabstr 0		: { *(.stabstr) }
+  .stab.excl 0		: { *(.stab.excl) }
+  .stab.exclstr 0	: { *(.stab.exclstr) }
+  .stab.index 0		: { *(.stab.index) }
+  .stab.indexstr 0	: { *(.stab.indexstr) }
+  .comment 0		: { *(.comment) }
+
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+
+  /* DWARF 1 */
+  .debug          0	: { *(.debug) }
+  .line           0	: { *(.line) }
+
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0	: { *(.debug_srcinfo) }
+  .debug_sfnames  0	: { *(.debug_sfnames) }
+
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0	: { *(.debug_aranges) }
+  .debug_pubnames 0	: { *(.debug_pubnames) }
+
+  /* DWARF 2 */
+  .debug_info     0	: { *(.debug_info) *(.gnu.linkonce.wi.*) }
+  .debug_abbrev   0	: { *(.debug_abbrev) }
+  .debug_line     0	: { *(.debug_line) }
+  .debug_frame    0	: { *(.debug_frame) }
+  .debug_str      0	: { *(.debug_str) }
+  .debug_loc      0	: { *(.debug_loc) }
+  .debug_macinfo  0	: { *(.debug_macinfo) }
+
+  /* SGI/MIPS DWARF 2 extensions.  */
+  .debug_weaknames 0	: { *(.debug_weaknames) }
+  .debug_funcnames 0	: { *(.debug_funcnames) }
+  .debug_typenames 0	: { *(.debug_typenames) }
+  .debug_varnames  0	: { *(.debug_varnames) }
+
+  /* User stack.  */
+  .stack 0x200000	:
+  {
+	${RELOCATING+__stack = .;}
+	*(.stack)
+  }
+}
+EOF
diff -Nbaur binutils-2.23.1/opcodes/Makefile.am binutils-2.23.1-v810/opcodes/Makefile.am
--- binutils-2.23.1/opcodes/Makefile.am	2012-09-04 15:21:06 +0100
+++ binutils-2.23.1-v810/opcodes/Makefile.am	2013-03-09 17:59:22 +0000
@@ -227,6 +227,8 @@
 	tilegx-opc.c \
 	tilepro-dis.c \
 	tilepro-opc.c \
+	v810-dis.c \
+	v810-opc.c \
 	v850-dis.c \
 	v850-opc.c \
 	vax-dis.c \
diff -Nbaur binutils-2.23.1/opcodes/Makefile.in binutils-2.23.1-v810/opcodes/Makefile.in
--- binutils-2.23.1/opcodes/Makefile.in	2012-09-04 15:21:06 +0100
+++ binutils-2.23.1-v810/opcodes/Makefile.in	2013-03-09 17:59:22 +0000
@@ -498,6 +498,8 @@
 	tilegx-opc.c \
 	tilepro-dis.c \
 	tilepro-opc.c \
+	v810-dis.c \
+	v810-opc.c \
 	v850-dis.c \
 	v850-opc.c \
 	vax-dis.c \
@@ -894,6 +896,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tilegx-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tilepro-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tilepro-opc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/v810-dis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/v810-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/v850-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/v850-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vax-dis.Plo@am__quote@
diff -Nbaur binutils-2.23.1/opcodes/configure binutils-2.23.1-v810/opcodes/configure
--- binutils-2.23.1/opcodes/configure	2012-09-04 15:21:07 +0100
+++ binutils-2.23.1-v810/opcodes/configure	2013-03-09 17:59:22 +0000
@@ -12570,6 +12570,8 @@
 	bfd_tic80_arch)		ta="$ta tic80-dis.lo tic80-opc.lo" ;;
 	bfd_tilegx_arch)	ta="$ta tilegx-dis.lo tilegx-opc.lo" ;;
 	bfd_tilepro_arch)	ta="$ta tilepro-dis.lo tilepro-opc.lo" ;;
+	bfd_v810_arch)		ta="$ta v810-opc.lo v810-dis.lo" ;;
+	bfd_v830_arch)		ta="$ta v810-opc.lo v810-dis.lo" ;;
 	bfd_v850_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850e_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850ea_arch)	ta="$ta v850-opc.lo v850-dis.lo" ;;
diff -Nbaur binutils-2.23.1/opcodes/configure.in binutils-2.23.1-v810/opcodes/configure.in
--- binutils-2.23.1/opcodes/configure.in	2012-11-05 16:29:08 +0000
+++ binutils-2.23.1-v810/opcodes/configure.in	2013-03-09 17:59:22 +0000
@@ -315,6 +315,8 @@
 	bfd_tic80_arch)		ta="$ta tic80-dis.lo tic80-opc.lo" ;;
 	bfd_tilegx_arch)	ta="$ta tilegx-dis.lo tilegx-opc.lo" ;;
 	bfd_tilepro_arch)	ta="$ta tilepro-dis.lo tilepro-opc.lo" ;;
+	bfd_v810_arch)		ta="$ta v810-opc.lo v810-dis.lo" ;;
+	bfd_v830_arch)		ta="$ta v810-opc.lo v810-dis.lo" ;;
 	bfd_v850_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850e_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850ea_arch)	ta="$ta v850-opc.lo v850-dis.lo" ;;
diff -Nbaur binutils-2.23.1/opcodes/disassemble.c binutils-2.23.1-v810/opcodes/disassemble.c
--- binutils-2.23.1/opcodes/disassemble.c	2012-09-04 13:53:50 +0100
+++ binutils-2.23.1-v810/opcodes/disassemble.c	2013-03-09 17:59:22 +0000
@@ -87,6 +87,7 @@
 #define ARCH_tic80
 #define ARCH_tilegx
 #define ARCH_tilepro
+#define ARCH_v810
 #define ARCH_v850
 #define ARCH_vax
 #define ARCH_w65
@@ -434,6 +435,11 @@
       disassemble = print_insn_tic80;
       break;
 #endif
+#ifdef ARCH_v810
+    case bfd_arch_v810:
+      disassemble = print_insn_v810;
+      break;
+#endif
 #ifdef ARCH_v850
     case bfd_arch_v850:
       disassemble = print_insn_v850;
diff -Nbaur binutils-2.23.1/opcodes/v810-dis.c binutils-2.23.1-v810/opcodes/v810-dis.c
--- binutils-2.23.1/opcodes/v810-dis.c	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/opcodes/v810-dis.c	2013-03-09 17:59:22 +0000
@@ -0,0 +1,244 @@
+/* Disassemble V810 instructions.
+   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2005, 2007
+   Free Software Foundation, Inc.
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+
+#include <stdio.h>
+
+#include "sysdep.h"
+#include "opcode/v810.h"
+#include "dis-asm.h"
+#include "opintl.h"
+
+static const char *const v810_reg_names[] =
+{ "r0", "r1", "r2", "sp", "gp", "r5", "r6", "r7",
+  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
+  "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
+  "r24", "r25", "r26", "r27", "r28", "r29", "r30", "lp" };
+
+static const char *const v810_sreg_names[] =
+{ "eipc", "eipsw", "fepc", "fepsw", "ecr", "psw", "pir", "tkcw",
+  "sr8", "sr9", "sr10", "sr11", "sr12", "sr13", "sr14", "sr15",
+  "sr16", "sr17", "sr18", "sr19", "sr20", "sr21", "sr22", "sr23",
+  "chcw", "adtre", "sr26", "sr27", "sr28", "sr29", "sr30", "sr31" };
+
+static const char *const v810_cc_names[] =
+{ "v", "c/l", "z", "nh", "s/n", "t", "lt", "le",
+  "nv", "nc/nl", "nz", "h", "ns/p", "sa", "ge", "gt" };
+
+static int
+disassemble (bfd_vma memaddr,
+	     struct disassemble_info * info,
+	     unsigned long insn)
+{
+  struct v810_opcode * op = (struct v810_opcode *) v810_opcodes;
+  const struct v810_operand * operand;
+  int match = 0;
+  int short_op = ((insn & 0xfc00) < 0xa000);
+  int bytes_read;
+  int target_processor;
+
+  bytes_read = short_op ? 2 : 4;
+
+  /* If this is a two byte insn, then mask off the high bits.  */
+  if (short_op)
+    insn &= 0xffff;
+
+  switch (info->mach)
+    {
+    case 0:
+    default:
+      target_processor = PROCESSOR_V810;
+      break;
+
+    case bfd_mach_v830:
+      target_processor = PROCESSOR_V830;
+      break;
+    }
+
+  /* Find the opcode.  */
+  while (op->name)
+    {
+      if ((op->mask & insn) == op->opcode
+	  && (op->processors & target_processor))
+	{
+	  const unsigned char *opindex_ptr;
+	  unsigned int opnum;
+	  unsigned int memop;
+
+	  match = 1;
+	  (*info->fprintf_func) (info->stream, "%s\t", op->name);
+
+	  memop = op->memop;
+	  /* Now print the operands.
+
+	     MEMOP is the operand number at which a memory
+	     address specification starts, or zero if this
+	     instruction has no memory addresses.
+
+	     A memory address is always two arguments.
+
+	     This information allows us to determine when to
+	     insert commas into the output stream as well as
+	     when to insert disp[reg] expressions onto the
+	     output stream.  */
+
+	  for (opindex_ptr = op->operands, opnum = 1;
+	       *opindex_ptr != 0;
+	       opindex_ptr++, opnum++)
+	    {
+	      long value;
+	      int flag;
+
+	      operand = &v810_operands[*opindex_ptr];
+
+	      if (operand->extract)
+		value = (operand->extract) (insn, 0);
+	      else
+		{
+		  if (operand->bits == -1)
+		    value = (insn & operand->shift);
+		  else
+		    value = (insn >> operand->shift) & ((1 << operand->bits) - 1);
+
+		  if (operand->flags & V810_OPERAND_SIGNED)
+		    value = ((long)(value << (32 - operand->bits))
+			     >> (32 - operand->bits));
+		}
+
+	      /* The first operand is always output without any
+		 special handling.
+
+		 For the following arguments:
+
+		   If memop && opnum == memop + 1, then we need '[' since
+		   we're about to output the register used in a memory
+		   reference.
+
+		   If memop && opnum == memop + 2, then we need ']' since
+		   we just finished the register in a memory reference.  We
+		   also need a ',' before this operand.
+
+		   Else we just need a comma.
+
+		   We may need to output a trailing ']' if the last operand
+		   in an instruction is the register for a memory address.
+
+		   The exception (and there's always an exception) is the
+		   "jmp" insn which needs square brackets around it's only
+		   register argument.  */
+
+	           if (memop && opnum == memop + 1) info->fprintf_func (info->stream, "[");
+		   else if (memop && opnum == memop + 2) info->fprintf_func (info->stream, "],");
+		   else if (memop == 1 && opnum == 1 && (operand->flags & V810_OPERAND_REG))
+		     info->fprintf_func (info->stream, "[");
+		   else if (opnum > 1)
+		     info->fprintf_func (info->stream, ", ");
+
+	      /* Extract the flags, ignorng ones which
+		 do not effect disassembly output. */
+	      flag = operand->flags;
+	      flag &= ~ V810_OPERAND_SIGNED;
+	      flag &= ~ V810_OPERAND_RELAX;
+	      flag &= - flag;
+
+	      switch (flag)
+		{
+		case V810_OPERAND_REG:
+		  info->fprintf_func (info->stream, "%s", v810_reg_names[value]);
+		  break;
+		case V810_OPERAND_SRG:
+		  info->fprintf_func (info->stream, "%s", v810_sreg_names[value]);
+		  break;
+		case V810_OPERAND_CC:
+		  info->fprintf_func (info->stream, "%s", v810_cc_names[value]);
+		  break;
+		default:
+		  info->fprintf_func (info->stream, "%ld", value);
+		  break;
+		case V810_OPERAND_DISP:
+		  {
+		    bfd_vma addr = value + memaddr;
+		    info->print_address_func (addr, info);
+		    break;
+		  }
+		}
+
+	      /* Handle jmp correctly.  */
+	      if (memop == 1 && opnum == 1
+		  && ((operand->flags & V810_OPERAND_REG) != 0))
+		(*info->fprintf_func) (info->stream, "]");
+	    }
+
+	  /* Close any square bracket we left open.  */
+	  if (memop && opnum == memop + 2)
+	    (*info->fprintf_func) (info->stream, "]");
+
+	  /* All done. */
+	  break;
+	}
+      op++;
+    }
+
+  if (!match)
+    {
+      if (short_op)
+	info->fprintf_func (info->stream, ".short\t0x%04lx", insn);
+      else
+	info->fprintf_func (info->stream, ".long\t0x%08lx", insn);
+    }
+
+  return bytes_read;
+}
+
+int
+print_insn_v810 (bfd_vma memaddr, struct disassemble_info * info)
+{
+  int status;
+  bfd_byte buffer[4];
+  unsigned long insn = 0;
+
+  /* First figure out how big the opcode is.  */
+  status = info->read_memory_func (memaddr, buffer, 2, info);
+  if (status == 0)
+    {
+      insn = bfd_getl16 (buffer);
+
+/*      if (   (insn & 0x0600) == 0x0600
+	  && (insn & 0xffe0) != 0x0620)*/
+      if ((insn & 0xfc00) >= 0xa000)
+	{
+	  /* If this is a 4 byte insn, read 4 bytes of stuff.  */
+	  status = info->read_memory_func (memaddr, buffer, 4, info);
+
+	  if (status == 0)
+	    insn = bfd_getl32 (buffer);
+	}
+    }
+
+  if (status != 0)
+    {
+      info->memory_error_func (status, memaddr, info);
+      return -1;
+    }
+
+  /* Make sure we tell our caller how many bytes we consumed.  */
+  return disassemble (memaddr, info, insn);
+}
diff -Nbaur binutils-2.23.1/opcodes/v810-opc.c binutils-2.23.1-v810/opcodes/v810-opc.c
--- binutils-2.23.1/opcodes/v810-opc.c	1970-01-01 00:00:00 +0000
+++ binutils-2.23.1-v810/opcodes/v810-opc.c	2013-03-12 16:15:16 +0000
@@ -0,0 +1,430 @@
+/* Assemble V810 instructions.
+   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2005, 2007, 2010,
+   2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "opcode/v810.h"
+#include "bfd.h"
+#include "opintl.h"
+
+
+/* Regular opcodes.  */
+#define OP(x)		((x & 0x3f) << 10)
+#define OP_MASK		OP (0x3f)
+
+/* One-word opcodes.  */
+#define one(x)		((unsigned int) (x))
+
+/* Two-word opcodes.  */
+#define two(x,y)	((unsigned int) (x) | ((unsigned int) (y) << 16))
+
+
+/* The functions used to insert and extract complicated operands.  */
+
+/* Note: There is a conspiracy between these functions and
+   v810_insert_operand() in gas/config/tc-v810.c.  Error messages
+   containing the string 'out of range' will be ignored unless a
+   specific command line option is given to GAS.  */
+
+static const char * branch_out_of_range = N_ ("branch value out of range");
+static const char * branch_out_of_range_and_odd_offset = N_ ("branch value not in range and to odd offset");
+static const char * branch_to_odd_offset = N_ ("branch to odd offset");
+
+
+int
+v810_msg_is_out_of_range (const char* msg)
+{
+  return msg == branch_out_of_range;
+}
+
+static unsigned long
+insert_d9 (unsigned long insn, long value, const char ** errmsg)
+{
+  if (value > 0xff || value < -0x100)
+    {
+      if ((value % 2) != 0)
+	* errmsg = branch_out_of_range_and_odd_offset;
+      else
+	* errmsg = branch_out_of_range;
+    }
+  else if ((value % 2) != 0)
+    * errmsg = branch_to_odd_offset;
+
+  return insn | (value & 0x1fe);
+}
+
+static unsigned long
+extract_d9 (unsigned long insn, int * invalid)
+{
+  signed long ret = (insn & 0x1fe);
+
+  ret = (ret ^ 0x100) - 0x100;
+
+  if (invalid != 0)
+    *invalid = 0;
+  return ret;
+}
+
+static unsigned long
+insert_d26 (unsigned long insn, long value, const char ** errmsg)
+{
+  if (value > 0x1ffffff || value < -0x2000000)
+    {
+      if ((value % 2) != 0)
+	* errmsg = branch_out_of_range_and_odd_offset;
+      else
+	* errmsg = branch_out_of_range;
+    }
+  else if ((value % 2) != 0)
+    * errmsg = branch_to_odd_offset;
+
+  return insn | ((value & 0xfffe) << 16) | ((value & 0x3ff0000) >> 16);
+}
+
+static unsigned long
+extract_d26 (unsigned long insn, int * invalid)
+{
+  signed long ret = ((insn >> 16) & 0xfffe) | ((insn << 16) & 0x3ff0000);
+
+  ret = (ret ^ 0x2000000) - 0x2000000;
+
+  if (invalid != 0)
+    *invalid = 0;
+  return (unsigned long) ret;
+}
+
+/* Warning: code in gas/config/tc-v810.c examines the contents of this array.
+   If you change any of the values here, be sure to look for side effects in
+   that code.  */
+const struct v810_operand v810_operands[] =
+{
+#define UNUSED	0
+  { 0, 0, NULL, NULL, 0, BFD_RELOC_NONE },
+
+/* The R1 field in a format 1, 5, 6, 7 insn.  */
+#define R1	(UNUSED + 1)
+  { 5, 0, NULL, NULL, V810_OPERAND_REG, BFD_RELOC_NONE },
+
+/* The R2 field in a format 1, 2, 5, 6, 7 insn.  */
+#define R2 (R1 + 1)
+  { 5, 5, NULL, NULL, V810_OPERAND_REG, BFD_RELOC_NONE },
+
+/* The R3 field in a format 8 insn.  */
+#define R3	(R2 + 1)
+  { 5, 16, NULL, NULL, V810_OPERAND_REG, BFD_RELOC_NONE },
+
+/* System register operands.  */
+#define SR	(R3 + 1)
+  { 5, 0, NULL, NULL, V810_OPERAND_SRG, BFD_RELOC_NONE },
+
+/* The 4 bit condition code in a setf instruction.  */
+#define CCCC	(SR + 1)
+  { 4, 0, NULL, NULL, V810_OPERAND_CC, BFD_RELOC_NONE },
+
+/* The imm5 field in a format 2 insn.  */
+#define I5	(CCCC + 1)
+  { 5, 0, NULL, NULL, V810_OPERAND_SIGNED, BFD_RELOC_NONE },
+
+/* The unsigned imm5 field in a format 2 insn.  */
+#define I5U	(I5 + 1)
+  { 5, 0, NULL, NULL, 0, BFD_RELOC_NONE },
+
+/* The imm16 field in a format 5 insn.  */
+#define I16	(I5U + 1)
+  { 16, 16, NULL, NULL, V810_OPERAND_SIGNED, BFD_RELOC_16 },
+
+/* The unsigned imm16 in a format 5 insn.  */
+#define I16U	(I16 + 1)
+  { 16, 16, NULL, NULL, 0, BFD_RELOC_16 },
+
+/* The disp16 field in a format 6 insn.  */
+#define D16	(I16U + 1)
+  { 16, 16, NULL, NULL, V810_OPERAND_SIGNED | V810_OPERAND_DISP, BFD_RELOC_16 },
+
+/* The DISP9 field in a format 3 insn, relaxable.  */
+#define D9_RELAX	(D16 + 1)
+  { 9, 0, insert_d9, extract_d9, V810_OPERAND_RELAX | V810_OPERAND_SIGNED | V810_OPERAND_DISP | V810_PCREL, BFD_RELOC_V810_9_PCREL },
+
+/* The DISP26 field in a format 4 insn, relaxable.
+   This _must_ follow D9_RELAX; the assembler assumes that the longer
+   version immediately follows the shorter version for relaxing.  */
+#define D26	(D9_RELAX + 1)
+  { 26, 0, insert_d26, extract_d26, V810_OPERAND_SIGNED | V810_OPERAND_DISP | V810_PCREL, BFD_RELOC_V810_26_PCREL },
+
+};
+
+
+/* Reg - Reg instruction format (Format I).  */
+#define IF1	{R1, R2}
+
+/* Imm - Reg instruction format (Format II).  */
+#define IF2	{I5, R2}
+
+/* Conditional branch instruction format (Format III).  */
+#define IF3	{D9_RELAX}
+
+/* 3 operand instruction (Format V).  */
+#define IF5	{I16, R1, R2}
+
+/* 3 operand instruction (Format V).  */
+#define IF5U	{I16U, R1, R2}
+
+
+/* The opcode table.
+
+   The format of the opcode table is:
+
+   NAME		OPCODE			MASK		       { OPERANDS }	   MEMOP    PROCESSOR
+
+   NAME is the name of the instruction.
+   OPCODE is the instruction opcode.
+   MASK is the opcode mask; this is used to tell the disassembler
+     which bits in the actual opcode must match OPCODE.
+   OPERANDS is the list of operands.
+   MEMOP specifies which operand (if any) is a memory operand.
+   PROCESSORS specifies which CPU(s) support the opcode.
+
+   The disassembler reads the table in order and prints the first
+   instruction which matches, so this table is sorted to put more
+   specific instructions before more general instructions.  It is also
+   sorted by major opcode.
+
+   The table is also sorted by name.  This is used by the assembler.
+   When parsing an instruction the assembler finds the first occurance
+   of the name of the instruciton in this table and then attempts to
+   match the instruction's arguments with description of the operands
+   associated with the entry it has just found in this table.  If the
+   match fails the assembler looks at the next entry in this table.
+   If that entry has the same name as the previous entry, then it
+   tries to match the instruction against that entry and so on.  This
+   is how the assembler copes with multiple, different formats of the
+   same instruction.  */
+
+const struct v810_opcode v810_opcodes[] =
+{
+/* Standard instructions.  */
+{ "add",	OP (0x01),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
+{ "add",	OP (0x11),		OP_MASK,		IF2, 			0, PROCESSOR_ALL },
+
+{ "addi",	OP (0x29),		OP_MASK,		IF5,			0, PROCESSOR_ALL },
+
+{ "and",	OP (0x0d),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
+
+{ "andi",	OP (0x2d),		OP_MASK,		IF5U, 			0, PROCESSOR_ALL },
+
+	/* Signed integer.  */
+{ "bge",	one (0x9c00),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "bgt",	one (0x9e00),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "ble",	one (0x8e00),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "blt",	one (0x8c00),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+	/* Unsigned integer.  */
+{ "bh",		one (0x9600),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "bl",		one (0x8200),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "bnh",	one (0x8600),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "bnl",	one (0x9200),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+	/* Common.  */
+{ "be",		one (0x8400),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "bne",	one (0x9400),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+	/* Others.  */
+{ "bc",		one (0x8200),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "bn",		one (0x8800),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "bnc",	one (0x9200),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "bnv",	one (0x9000),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "bnz",	one (0x9400),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "bp",		one (0x9800),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "br",		one (0x8a00),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "bv",		one (0x8000),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+{ "bz",		one (0x8400),		one (0xfe01),		IF3,			0, PROCESSOR_ALL },
+
+{ "caxi",	two (0xe800, 0x0000),	two (0xfc00, 0x0000),	{D16, R1, R2},		1, PROCESSOR_ALL },
+
+{ "cmp",	OP (0x03),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
+{ "cmp",	OP (0x13),		OP_MASK,		IF2, 			0, PROCESSOR_ALL },
+
+{ "div",	OP (0x09),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
+
+{ "divu",	OP (0x0b),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
+
+{ "halt",	one (0x6800),		one (0xffff),		{0}, 			0, PROCESSOR_ALL },
+
+{ "in.b",	two (0xe000, 0x0000),	two (0xfc00, 0x0000), 	{D16, R1, R2}, 		1, PROCESSOR_ALL },
+{ "in.h",	two (0xe400, 0x0000),	two (0xfc00, 0x0000), 	{D16, R1, R2}, 		1, PROCESSOR_ALL },
+{ "in.w",	two (0xec00, 0x0000),	two (0xfc00, 0x0000), 	{D16, R1, R2}, 		1, PROCESSOR_ALL },
+
+{ "jal",	two (0xac00, 0x0000),	two (0xfc00, 0x0000),	{D26},			0, PROCESSOR_ALL },
+
+{ "jmp",	one (0x1800),		one (0xfc00),		{R1},			1, PROCESSOR_ALL },
+
+{ "jr",		two (0xa800, 0x0000),	two (0xfc00, 0x0000),	{D26},			0, PROCESSOR_ALL },
+
+{ "ld.b",	two (0xc000, 0x0000),	two (0xfc00, 0x0000), 	{D16, R1, R2}, 		1, PROCESSOR_ALL },
+{ "ld.h",	two (0xc400, 0x0000),	two (0xfc00, 0x0000), 	{D16, R1, R2}, 		1, PROCESSOR_ALL },
+{ "ld.w",	two (0xcc00, 0x0000),	two (0xfc00, 0x0000), 	{D16, R1, R2}, 		1, PROCESSOR_ALL },
+
+{ "ldsr",	one (0x7000),		one (0xfc00),		{R2, SR}, 		0, PROCESSOR_ALL },
+
+{ "mov",	OP (0x00),		OP_MASK,		{R1, R2},		0, PROCESSOR_ALL },
+{ "mov",	OP (0x10),		OP_MASK,		{I5, R2},		0, PROCESSOR_ALL },
+
+{ "movea",	OP (0x28),		OP_MASK,		{I16, R1, R2},		0, PROCESSOR_ALL },
+
+{ "movhi",	OP (0x2f),		OP_MASK,		{I16, R1, R2},		0, PROCESSOR_ALL },
+
+{ "mul",	OP (0x08),		OP_MASK, 		IF1, 			0, PROCESSOR_ALL },
+
+{ "mulu",	OP (0x0a),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
+
+{ "nop",	one (0x9a00),		one (0xffff),		{0}, 			0, PROCESSOR_ALL },
+
+{ "not",	OP (0x0f),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
+
+{ "or",		OP (0x0c),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
+{ "ori",	OP (0x2c),		OP_MASK,		IF5U, 			0, PROCESSOR_ALL },
+
+{ "out.b",	two (0xf000, 0x0000),	two (0xfc00, 0x0000), 	{R2, D16, R1}, 		2, PROCESSOR_ALL },
+{ "out.h",	two (0xf400, 0x0000),	two (0xfc00, 0x0000), 	{R2, D16, R1}, 		2, PROCESSOR_ALL },
+{ "out.w",	two (0xfc00, 0x0000),	two (0xfc00, 0x0000), 	{R2, D16, R1}, 		2, PROCESSOR_ALL },
+
+{ "reti",	one (0x6400),		one (0xffff),		{0}, 			0, PROCESSOR_ALL },
+
+{ "sar",	OP (0x07),		OP_MASK,		{R1, R2}, 		0, PROCESSOR_ALL },
+{ "sar",	OP (0x17),		OP_MASK,		{I5U, R2}, 		0, PROCESSOR_ALL },
+
+{ "setf",	OP (0x12),		OP_MASK,		{CCCC, R2},		0, PROCESSOR_ALL },
+
+{ "shl",	OP (0x04),		OP_MASK,		{R1, R2}, 		0, PROCESSOR_ALL },
+{ "shl",	OP (0x14),		OP_MASK,		{I5U, R2}, 		0, PROCESSOR_ALL },
+
+{ "shr",	OP (0x05),		OP_MASK,		{R1, R2}, 		0, PROCESSOR_ALL },
+{ "shr",	OP (0x15),		OP_MASK,		{I5U, R2}, 		0, PROCESSOR_ALL },
+
+{ "st.b",	two (0xd000, 0x0000),	two (0xfc00, 0x0000), 	{R2, D16, R1}, 		2, PROCESSOR_ALL },
+{ "st.h",	two (0xd400, 0x0000),	two (0xfc00, 0x0000), 	{R2, D16, R1}, 		2, PROCESSOR_ALL },
+{ "st.w",	two (0xdc00, 0x0000),	two (0xfc00, 0x0000), 	{R2, D16, R1}, 		2, PROCESSOR_ALL },
+
+{ "stsr",	one (0x7400),		one (0xfc00),		{SR, R2}, 		0, PROCESSOR_ALL },
+
+{ "sub",	OP (0x02),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
+
+{ "trap",	one (0x6000),		one (0xfc00),		{I5U}, 			0, PROCESSOR_ALL },
+
+{ "xor",	OP (0x0e),		OP_MASK,		IF1, 			0, PROCESSOR_ALL },
+
+{ "xori",	OP (0x2e),		OP_MASK,		IF5U, 			0, PROCESSOR_ALL },
+
+/* NVC custom commands.  */
+{ "xb",		two (0xf800, 0x2000),	two (0xfc00, 0xfc00),	{R2}, 			0, PROCESSOR_V810 },
+{ "xh",		two (0xf800, 0x2400),	two (0xfc00, 0xfc00),	{R2}, 			0, PROCESSOR_V810 },
+
+{ "cli",	one (0x5800),		one (0xffff),		{0}, 			0, PROCESSOR_V810 },
+{ "sei",	one (0x7800),		one (0xffff),		{0}, 			0, PROCESSOR_V810 },
+
+{ "rev",	two (0xf800, 0x2800),	two (0xfc00, 0xfc00),	{R1, R2}, 		0, PROCESSOR_V810 },
+
+{ "mpyhw",	two (0xf800, 0x3000),	two (0xfc00, 0xfc00),	{R1, R2}, 		0, PROCESSOR_V810 },
+
+/* Floating point operation.  */
+{ "addf.s",	two (0xf800, 0x1000),	two (0xfc00, 0xfc00),	{R1, R2},		0, PROCESSOR_NOT_V830 },
+{ "cmpf.s",	two (0xf800, 0x0000),	two (0xfc00, 0xfc00),	{R1, R2},		0, PROCESSOR_NOT_V830 },
+{ "cvt.sw",	two (0xf800, 0x0c00),	two (0xfc00, 0xfc00),	{R1, R2},		0, PROCESSOR_NOT_V830 },
+{ "cvt.ws",	two (0xf800, 0x0800),	two (0xfc00, 0xfc00),	{R1, R2},		0, PROCESSOR_NOT_V830 },
+{ "divf.s",	two (0xf800, 0x1c00),	two (0xfc00, 0xfc00),	{R1, R2},		0, PROCESSOR_NOT_V830 },
+{ "mulf.s",	two (0xf800, 0x1800),	two (0xfc00, 0xfc00),	{R1, R2},		0, PROCESSOR_NOT_V830 },
+{ "subf.s",	two (0xf800, 0x1400),	two (0xfc00, 0xfc00),	{R1, R2},		0, PROCESSOR_NOT_V830 },
+{ "trnc.sw",	two (0xf800, 0x2c00),	two (0xfc00, 0xfc00),	{R1, R2},		0, PROCESSOR_NOT_V830 },
+
+/* Bit string instructions.  */
+{ "andbsu",	one (0x7c09),		one (0xffff),		{0}, 			0, PROCESSOR_NOT_V830 },
+{ "andnbsu",	one (0x7c0d),		one (0xffff),		{0}, 			0, PROCESSOR_NOT_V830 },
+
+{ "movbsu",	one (0x7c0b),		one (0xffff),		{0}, 			0, PROCESSOR_NOT_V830 },
+
+{ "notbsu",	one (0x7c0f),		one (0xffff),		{0}, 			0, PROCESSOR_NOT_V830 },
+
+{ "orbsu",	one (0x7c08),		one (0xffff),		{0}, 			0, PROCESSOR_NOT_V830 },
+{ "ornbsu",	one (0x7c0c),		one (0xffff),		{0},			0, PROCESSOR_NOT_V830 },
+
+{ "sch0bsu",	one (0x7c00),		one (0xffff),		{0},			0, PROCESSOR_NOT_V830 },
+{ "sch0bsd",	one (0x7c01),		one (0xffff),		{0},			0, PROCESSOR_NOT_V830 },
+{ "sch1bsu",	one (0x7c02),		one (0xffff),		{0},			0, PROCESSOR_NOT_V830 },
+{ "sch1bsd",	one (0x7c03),		one (0xffff),		{0},			0, PROCESSOR_NOT_V830 },
+
+{ "xorbsu",	one (0x7c0a),		one (0xffff),		{0},			0, PROCESSOR_NOT_V830 },
+{ "xornbsu",	one (0x7c0e),		one (0xffff),		{0},			0, PROCESSOR_NOT_V830 },
+
+/* V830 instructions.  */
+{ "abc",	one (0x8201),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abe",	one (0x8401),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abge",	one (0x9c01),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abgt",	one (0x9e01),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abh",	one (0x9601),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abl",	one (0x8201),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "able",	one (0x8e01),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "ablt",	one (0x8c01),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abn",	one (0x8801),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abnc",	one (0x9201),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abne",	one (0x9401),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abnh",	one (0x8601),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abnl",	one (0x9201),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abnv",	one (0x9001),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abnz",	one (0x9401),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abp",	one (0x9801),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abr",	one (0x8a01),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abv",	one (0x8001),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+{ "abz",	one (0x8401),		one (0xfe01),		IF3,			0, PROCESSOR_V830 },
+
+{ "bdld",	two (0xf800, 0x8400),	two (0xfc00, 0xfc00),	{R1, R2}, 		0, PROCESSOR_V830 },
+{ "bdst",	two (0xf800, 0x8c00),	two (0xfc00, 0xfc00),	{R2, R1}, 		0, PROCESSOR_V830 },
+{ "bild",	two (0xf800, 0x8000),	two (0xfc00, 0xfc00),	{R1, R2}, 		0, PROCESSOR_V830 },
+{ "bist",	two (0xf800, 0x8800),	two (0xfc00, 0xfc00),	{R2, R1}, 		0, PROCESSOR_V830 },
+
+{ "brkret",	one (0x6401),		one (0xfc01),		{0}, 			0, PROCESSOR_V830 },
+
+{ "di",		one (0x7800),		one (0xfc00),		{0}, 			0, PROCESSOR_V830 },
+{ "ei",		one (0x5800),		one (0xfc00),		{0}, 			0, PROCESSOR_V830 },
+
+{ "min3",	two (0xf800, 0x4800),	two (0xfc00, 0xfc00),	{R1, R2, R3}, 		0, PROCESSOR_V830 },
+{ "max3",	two (0xf800, 0x4c00),	two (0xfc00, 0xfc00),	{R1, R2, R3}, 		0, PROCESSOR_V830 },
+
+{ "mul3",	two (0xf800, 0x7c00),	two (0xfc00, 0xfc00),	{R1, R2, R3}, 		0, PROCESSOR_V830 },
+{ "muli",	two (0xc800, 0x0000),	two (0xfc00, 0x0000),	{I16, R1, R2},		0, PROCESSOR_V830 },
+{ "mult3",	two (0xf800, 0x7800),	two (0xfc00, 0xfc00),	{R1, R2, R3}, 		0, PROCESSOR_V830 },
+
+{ "mac3",	two (0xf800, 0xf800),	two (0xfc00, 0xfc00),	{R1, R2}, 		0, PROCESSOR_V830 },
+{ "maci",	two (0xd800, 0x0000),	two (0xfc00, 0x0000),	{I16, R1, R2},		0, PROCESSOR_V830 },
+{ "mact3",	two (0xf800, 0x7000),	two (0xfc00, 0xfc00),	{R1, R2}, 		0, PROCESSOR_V830 },
+
+{ "satadd3",	two (0xf800, 0x4000),	two (0xfc00, 0xfc00),	{R1, R2, R3}, 		0, PROCESSOR_V830 },
+{ "satsub3",	two (0xf800, 0x4400),	two (0xfc00, 0xfc00),	{R1, R2, R3}, 		0, PROCESSOR_V830 },
+
+{ "shld3",	two (0xf800, 0x6000),	two (0xfc00, 0xfc00),	{R1, R2, R3}, 		0, PROCESSOR_V830 },
+{ "shrd3",	two (0xf800, 0x6400),	two (0xfc00, 0xfc00),	{R1, R2, R3}, 		0, PROCESSOR_V830 },
+
+{ "stby",	one (0x6801),		one (0xfc01),		{0}, 			0, PROCESSOR_V830 },
+
+  /* Special instruction (from gdb) mov 1, r0.  */
+{ "breakpoint",	one (0x0001),		one (0xffff),		{UNUSED},		0, PROCESSOR_ALL },
+
+{ 0, 0, 0, {0}, 0, 0 },
+} ;
+
+const int v810_num_opcodes =
+  sizeof (v810_opcodes) / sizeof (v810_opcodes[0]);
